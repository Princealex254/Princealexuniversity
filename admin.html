<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Admin Panel — Prince Alex Design University</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" xintegrity="sha512-SzlrxWUlpfuzQ+pcUCosxcglQRNAq/DZjVsC0lE40xsADsfeQoEypE+enwcOiGJK5bR7C8e6jG1LMlC/j/cXuw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    /* Base variables and styles from admin (1).html */
    :root {
      --bg:#f6f8fb; --card:#ffffff; --text:#1f2937; --muted:#6b7280; --primary:#065f46; --primary-600:#047857; --ring:rgba(0,0,0,.06);
    }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; color: var(--text);}    
    
    /* Background for login from previous admin.html */
    body.login-bg {
        background: url('myschoolgate.png') no-repeat center center fixed;
        background-size: cover;
    }

    /* Topbar from admin (1).html */
    header { position: sticky; top:0; z-index:50; display:flex; align-items:center; justify-content:space-between; padding:12px 18px; background:var(--card); box-shadow: 0 2px 12px var(--ring); }    
    header .brand { display:flex; align-items:center; gap:10px; font-weight:700; }
    header img.logo { width:36px; height:36px; object-fit:cover; border-radius:8px; }
    header .actions { display:flex; align-items:center; gap:10px; }
    .btn { display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; cursor:pointer; }
    .btn.primary { background: var(--primary); border-color: var(--primary); color:#fff; }
    .btn.primary:hover { background: var(--primary-600);} 

    /* Layout for dashboard from admin (1).html */
    .layout { display:flex; min-height: calc(100vh - 60px); background: var(--bg); }    
    .sidebar { width: 230px; background: var(--card); border-right:1px solid #e5e7eb; padding:14px; position:sticky; top:60px; height: calc(100vh - 60px); overflow:auto; }
    .menu { display:flex; flex-direction:column; gap:6px; }
    .menu .item { display:flex; align-items:center; gap:10px; padding:10px 12px; border-radius:10px; color: var(--text); cursor:pointer; }
    .menu .item:hover { background:#f3f4f6; }
    .menu .item.active { background:#ecfdf5; color: var(--primary); font-weight:600; }

    .main { flex:1; padding:24px; }

    /* Section header from admin (1).html */
    .section-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:16px; }
    .section-title { display:flex; align-items:center; gap:10px; font-size:1.25rem; font-weight:700; }

    /* Cards grid from admin (1).html */
    .cards { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:18px; }
    .card { background: var(--card); border:1px solid #e5e7eb; border-radius:14px; padding:16px; box-shadow: 0 6px 14px var(--ring); }
    .card h4 { margin:0 0 8px; font-size:1rem; }
    .card .value { font-size:1.6rem; font-weight:800; }
    .card .muted { color: var(--muted); font-size:.85rem; }

    /* Tables from admin (1).html */
    .table-container { overflow-x: auto; } /* Added for responsiveness of tables */
    .table { width:100%; border-collapse: collapse; }
    .table th, .table td { padding:12px; border-bottom:1px solid #ececec; text-align:left; }
    .table th { font-size:.85rem; color: var(--muted); font-weight:600; }
    /* Actions column styling for better appearance */
    .table td.actions-cell {
        text-align: right;
        white-space: nowrap; /* Prevent buttons from wrapping */
    }
    .table td.actions-cell .btn {
        padding: 6px 10px;
        font-size: 0.8rem;
        border-radius: 8px;
        margin-left: 5px; /* Spacing between buttons */
    }

    /* Empty state from admin (1).html */
    .empty { background: #f9fafb; border:1px dashed #e5e7eb; border-radius:14px; padding:32px; text-align:center; color:var(--muted);}    
    .empty i { font-size:28px; margin-bottom:8px; color:#c7cdd6; }

    /* Forms from admin (1).html */
    .form-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:12px; } /* Renamed to avoid conflict with auth-form */
    .field { display:flex; flex-direction:column; gap:6px; }
    .field label { font-size:.9rem; color: var(--muted);} 
    .field input, .field select, .field textarea { padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; background:#fff; width: 100%;} /* Added width: 100% and textarea */

    /* Loader & toast from admin (1).html */
    #overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(255,255,255,.8); z-index:1000; } /* Increased z-index */
    .spinner { width:36px; height:36px; border:4px solid #e5e7eb; border-top-color: var(--primary); border-radius:50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg);} }

    .toast { position: fixed; right:16px; bottom:16px; background:#111827; color:#fff; padding:12px 14px; border-radius:12px; display:none; z-index:999; box-shadow:0 8px 20px rgba(0,0,0,.25); } /* Increased z-index */

    /* Auth view from admin (1).html (adjusted slightly) */
    #login { display:none; max-width:380px; margin:48px auto; background: var(--card); padding:24px; border-radius:16px; box-shadow:0 10px 24px var(--ring); border:1px solid #e5e7eb; }
    #login h2 { margin:0 0 12px; }
    #login .field { margin-bottom:10px; }

    /* Custom Modal styles (from previous admin.html) */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000; /* Higher than other elements */
    }
    .modal-content {
        background-color: white;
        padding: 2rem;
        border-radius: 0.5rem;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    /* Responsive tweaks from admin (1).html */
    @media (max-width: 920px) {
      .sidebar { position: fixed; left:-260px; transition: left .2s ease; }
      .sidebar.open { left:0; }
      .main { padding:18px; }
      header .hide-mobile { display:none; }
      header #toggleSidebar { display: block; } /* Ensure toggle button is visible on mobile */
    }

    /* Additional styles for sections */
    .profile-photo {
        width: 96px; /* w-24 */
        height: 96px; /* h-24 */
        border-radius: 9999px; /* rounded-full */
        object-fit: cover;
        border: 4px solid #99f6e4; /* border-green-200 */
    }
  </style>
</head>
<body class="login-bg">
  <!-- Loading Overlay and Modals (from previous admin.html) -->
  <div id="overlay" class="fixed inset-0 bg-white bg-opacity-90 flex flex-col justify-center items-center z-[2000] hidden">
      <div class="spinner"></div>
      <div id="loadingText" class="mt-4 text-xl text-green-700">Loading...</div>
  </div>

  <div id="customModal" class="modal-overlay hidden">
      <div class="modal-content">
          <h3 id="modalTitle" class="text-2xl font-semibold mb-4 text-green-800"></h3>
          <p id="modalMessage" class="mb-6 text-gray-700"></p>
          <div class="flex justify-center gap-4">
              <button id="modalConfirmBtn" class="bg-green-700 hover:bg-green-800 text-white font-bold py-2 px-6 rounded-md transition duration-300 ease-in-out">OK</button>
              <button id="modalCancelBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-6 rounded-md transition duration-300 ease-in-out hidden">Cancel</button>
          </div>
      </div>
  </div>

  <!-- Login View (from admin (1).html) -->
  <section id="login">
    <h2>Admin Login</h2>
    <div class="field"><label>Email</label><input id="email" type="email" placeholder="admin@example.com" /></div>
    <div class="field"><label>Password</label><input id="password" type="password" placeholder="••••••••" /></div>
    <button class="btn primary" id="loginBtn"><i class="fa-solid fa-right-to-bracket"></i> Sign In</button>
    <div id="loginHint" class="muted" style="margin-top:10px; font-size:.9rem; color:var(--muted);">Use a Firebase Auth user whose UID exists in <code>admins/{uid}</code> with <code>isAdmin: true</code>.</div>
  </section>

  <!-- Main App Layout (from admin (1).html) -->
  <header id="appHeader" class="hidden">
    <div class="brand">
      <img class="logo" src="myschoollogo.png" alt="Logo" />
      <span>Admin Panel</span>
    </div>
    <div class="actions">
      <button id="toggleSidebar" class="btn lg:hidden" title="Menu"><i class="fa-solid fa-bars"></i></button>
      <span class="hide-mobile" id="whoami">—</span>
      <button id="logoutBtn" class="btn"><i class="fa-solid fa-right-from-bracket"></i> Logout</button>
    </div>
  </header>

  <div class="layout hidden" id="dashboardLayout">
    <aside class="sidebar" id="sidebar">
      <nav class="menu" id="menu">
        <div class="item active" data-view="dashboard"><i class="fa-solid fa-gauge"></i> Dashboard</div>
        <div class="item" data-view="students"><i class="fa-solid fa-user-graduate"></i> Students</div>
        <div class="item" data-view="courses"><i class="fa-solid fa-book"></i> Courses</div>
        <div class="item" data-view="registrations"><i class="fa-solid fa-clipboard-list"></i> Registrations</div>
        <div class="item" data-view="fees"><i class="fa-solid fa-money-bill-wave"></i> Fees</div>
        <div class="item" data-view="grades"><i class="fa-solid fa-award"></i> Grades</div>
        <div class="item" data-view="hostels"><i class="fa-solid fa-building"></i> Hostels</div>
        <div class="item" data-view="announcements"><i class="fa-solid fa-bullhorn"></i> Announcements</div>
        <div class="item" data-view="graduation"><i class="fa-solid fa-graduation-cap"></i> Graduation Requests</div>
        <div class="item" data-view="clearance"><i class="fa-solid fa-check-circle"></i> Clearance Requests</div>
        <div class="item" data-view="admin-users"><i class="fa-solid fa-user-shield"></i> Admin Users</div>
        <div class="item" data-view="settings"><i class="fa-solid fa-gear"></i> Settings</div>
      </nav>
    </aside>

    <main class="main" id="main">
      <!-- Views render here dynamically by JavaScript -->
    </main>
  </div>

  <div class="toast" id="toast"></div>

  <script type="module">
    // Firebase SDK imports (v11.6.1 from admin (1).html)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, collection, addDoc, getDocs, query, where, updateDoc, deleteDoc, serverTimestamp, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

    // Firebase Config (Placeholder for canvas environment)
    const hardcodedFirebaseConfig = {
      apiKey: "YOUR_API_KEY", // Replace with your actual Firebase API Key if not using Canvas
      authDomain: "YOUR_AUTH_DOMAIN",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_STORAGE_BUCKET",
      messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
      appId: "YOUR_APP_ID"
    };

    // Use Canvas provided variables if available
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : hardcodedFirebaseConfig;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    const appId = typeof __app_id !== 'undefined' ? __app_id : hardcodedFirebaseConfig.projectId;


    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // UI Utilities (from admin (1).html, adapted)
    const qs = (s, el=document) => el.querySelector(s);
    const qsa = (s, el=document) => [...el.querySelectorAll(s)];
    const overlay = qs('#overlay');
    const toastEl = qs('#toast');
    
    function loading(on, message = 'Loading...') { 
        qs('#loadingText').textContent = message;
        overlay.style.display = on ? 'flex' : 'none'; 
    }
    function toast(msg, ms=2600) { 
        toastEl.textContent = msg; 
        toastEl.style.display='block'; 
        setTimeout(()=> toastEl.style.display='none', ms); 
    }

    // Custom Modal Functions (from previous admin.html)
    function showCustomModal(title, message, isConfirmation = false, onConfirm, onCancel) {
        return new Promise((resolve) => {
            const modal = document.getElementById('customModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');

            if (modalTitle) modalTitle.innerText = title;
            if (modalMessage) modalMessage.innerText = message;

            modalConfirmBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(true);
                if (onConfirm) onConfirm();
            };
            modalCancelBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(false);
                if (onCancel) onCancel();
            };

            if (isConfirmation) {
                modalCancelBtn.classList.remove('hidden');
            } else {
                modalCancelBtn.classList.add('hidden');
            }
            modal.classList.remove('hidden');
        });
    }

    // Override alert/confirm (from previous admin.html)
    window.alert = (message) => showCustomModal('Alert', message);
    window.confirm = (message) => showCustomModal('Confirm', message, true);

    // Simple view router
    const main = qs('#main');
    const appHeader = qs('#appHeader');
    const loginView = qs('#login');
    const dashboardLayout = qs('#dashboardLayout');
    const whoami = qs('#whoami');
    const logoutBtn = qs('#logoutBtn');
    const toggleSidebar = qs('#toggleSidebar');

    let currentAdminStudentId = null; // Used for fees/grades management

    // Attach initial event listeners
    qs('#loginBtn').addEventListener('click', handleLogin);
    logoutBtn.addEventListener('click', confirmLogout);
    toggleSidebar.addEventListener('click', () => {
        qs('#sidebar').classList.toggle('open');
    });

    // Menu interactions
    const menu = qs('#menu');
    menu.addEventListener('click', (e) => {
      const item = e.target.closest('.item');
      if (!item) return;
      qsa('.menu .item').forEach(i=> i.classList.remove('active'));
      item.classList.add('active');
      const view = item.dataset.view;
      if (viewHandlers[view]) viewHandlers[view]();
      qs('#sidebar').classList.remove('open'); // Close sidebar on mobile after selection
    });

    /********************
     * Auth Flow — UID-based admins
     ********************/
    onAuthStateChanged(auth, async (user) => {
      loading(true, 'Checking authentication...');
      if (!user) {
        showLogin();
        loading(false);
        document.body.classList.add('login-bg'); // Ensure background for login
        return;
      }

      whoami.textContent = user.email || user.uid || '—';
      document.body.classList.remove('login-bg'); // Remove background for dashboard

      try {
        // Admin check: admins/{uid} must exist and have isAdmin == true
        const adminRef = doc(db, 'admins', user.uid);
        const adminSnap = await getDoc(adminRef);
        if (!adminSnap.exists() || adminSnap.data().isAdmin !== true) {
          showLogin();
          loading(false);
          toast('You are not authorized as an administrator.');
          await signOut(auth); // Sign out if not an admin
          return;
        }

        // Authorized → render default view
        showApp();
        renderDashboard(); // Initial load to dashboard section
      } catch (err) {
        console.error('Admin check error:', err);
        toast('Login error: ' + err.message);
        showLogin();
        await signOut(auth); // Sign out on any error during admin check
      } finally {
        loading(false);
      }
    });

    async function handleLogin() {
        const email = qs('#email').value.trim();
        const password = qs('#password').value;
        if (!email || !password) {
            toast('Enter email and password');
            return;
        }
        loading(true, 'Signing in...');
        try {
            await signInWithEmailAndPassword(auth, email, password);
            // onAuthStateChanged will handle UI transition and admin check
        } catch (err) {
            let errorMessage = 'Login failed.';
            if (err.code === 'auth/user-not-found' || err.code === 'auth/wrong-password' || err.code === 'auth/invalid-credential') {
                errorMessage = 'Invalid email or password.';
            } else if (err.code === 'auth/invalid-email') {
                errorMessage = 'The email address is not valid.';
            } else if (err.code === 'auth/too-many-requests') {
                errorMessage = 'Too many login attempts. Please try again later.';
            }
            console.error('Sign-in error', err);
            toast(errorMessage);
        } finally {
            loading(false);
        }
    }

    async function confirmLogout() {
      const confirmed = await showCustomModal('Confirm Logout', 'Are you sure you want to log out?', true);
      if (confirmed) {
        loading(true, 'Logging out...');
        try {
          await signOut(auth);
          toast('Signed out');
          showLogin();
        } catch (err) {
          console.error('Logout error', err);
          toast('Error logging out: ' + err.message);
        } finally {
          loading(false);
        }
      }
    }

    function showLogin() {
      loginView.style.display = 'block';
      appHeader.classList.add('hidden');
      dashboardLayout.classList.add('hidden');
      document.body.classList.add('login-bg');
    }

    function showApp() {
      loginView.style.display = 'none';
      appHeader.classList.remove('hidden');
      dashboardLayout.classList.remove('hidden');
      document.body.classList.remove('login-bg');
    }

    /********************
     * Helpers (from admin (1).html)
     ********************/
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[s]));
    }
    function fmtDate(ts) {
      if (!ts) return '—';
      try {
        const d = ts.toDate ? ts.toDate() : new Date(ts);
        return d.toLocaleDateString(); // Simplified to just date
      } catch { return '—'; }
    }

    // Generic table renderer (adapted from previous admin.html)
    function renderTable(tableId, data, columns, actions) {
        const tableBody = document.querySelector(`#${tableId} tbody`);
        if (!tableBody) {
            console.error(`Table body for ID ${tableId} not found.`);
            return;
        }
        tableBody.innerHTML = ''; // Clear existing data

        if (data.length === 0) {
            const colCount = columns.length + (actions ? 1 : 0); // Include actions column for colspan
            tableBody.innerHTML = `<tr><td colspan="${colCount}" class="empty">
                                    <i class="fa-solid fa-database"></i>
                                    <div>No data available.</div>
                                    </td></tr>`;
            return;
        }

        data.forEach(item => {
            const row = document.createElement('tr');
            columns.forEach(col => {
                const cell = document.createElement('td');
                if (col === 'balance') {
                    cell.innerText = `GHS ${item[col].toFixed(2)}`;
                    cell.classList.add(item[col] > 0 ? 'text-red-600' : 'text-green-600');
                } else if (col.toLowerCase().includes('date') || col.toLowerCase().includes('at') || col.toLowerCase().includes('submissiondate') || col.toLowerCase().includes('applicationdate')) { // Handle date fields
                    try {
                        cell.innerText = item[col] ? new Date(item[col]).toLocaleDateString() : 'N/A';
                    } catch (e) {
                        cell.innerText = item[col] || 'N/A';
                    }
                } else if (col === 'isAdmin') {
                    cell.innerText = item[col] ? 'Yes' : 'No';
                } else if (col === 'documentURL') {
                    cell.innerHTML = item[col] ? `<a href="${escapeHtml(item[col])}" target="_blank" class="text-blue-500 hover:underline">View Document</a>` : 'N/A';
                }
                else {
                    cell.innerText = escapeHtml(item[col] || 'N/A');
                }
                row.appendChild(cell);
            });

            if (actions) {
                const actionsCell = document.createElement('td');
                actionsCell.className = "actions-cell"; // Use new class for actions styling
                actions.forEach(action => {
                    if (!action.condition || action.condition(item)) {
                        const button = document.createElement('button');
                        button.innerText = action.text;
                        button.className = `btn ${action.class}`; // Apply general btn class
                        button.onclick = () => action.handler(item);
                        actionsCell.appendChild(button);
                    }
                });
                row.appendChild(actionsCell);
            }
            tableBody.appendChild(row);
        });
    }

    // Export and Print Functions (from previous admin.html)
    function exportTable(tableId, filename) {
        loading(true, 'Exporting data...');
        try {
            const table = document.getElementById(tableId);
            if (!table) {
                showCustomModal('Error', 'Table not found for export.', false);
                return;
            }

            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.innerText);
            const allRows = Array.from(table.querySelectorAll('tbody tr'));
            
            const hasData = allRows.length > 0 && allRows[0].cells.length > 1 && !allRows[0].innerText.includes('No data available');

            let data = [];
            if (hasData || headers.length > 0) {
                data.push(headers.filter(header => header !== '')); // Exclude "Actions" header, assuming it's an empty string after map
            }
            
            if (hasData) {
                allRows.forEach(tr => {
                    const rowData = Array.from(tr.querySelectorAll('td'))
                                     .map(td => td.innerText)
                                     .filter((_, index, arr) => index !== arr.length - 1); // Exclude last column (Actions)
                    data.push(rowData);
                });
            }

            if (data.length <= 1 && hasData === false) {
                showCustomModal('Info', 'No data to export.', false);
                return;
            }

            const ws = XLSX.utils.aoa_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, filename);

            XLSX.writeFile(wb, `${filename}.xlsx`);
            showCustomModal('Success', 'Data exported successfully as Excel/CSV.', false);
        } catch (error) {
            showCustomModal('Error', 'Failed to export data: ' + error.message, false);
            console.error("Error exporting table:", error); // Log detailed error
        } finally {
            loading(false);
        }
    }
    
    function printTable(tableId, title) {
        loading(true, 'Preparing to print...');
        try {
            const table = document.getElementById(tableId);
            if (!table) {
                showCustomModal('Error', 'Table not found for printing.', false);
                return;
            }
            
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.innerText);
            const allRows = Array.from(table.querySelectorAll('tbody tr'));
            const hasData = allRows.length > 0 && allRows[0].cells.length > 1 && !allRows[0].innerText.includes('No data available');

            if (!hasData) {
                showCustomModal('Info', 'No data to print.', false);
                return;
            }

            const rows = allRows.map(tr => 
                Array.from(tr.querySelectorAll('td'))
                        .map(td => td.innerText)
                        .filter((_, index, arr) => index !== arr.length - 1) // Exclude last column (Actions)
            );
            
            const doc = new jspdf.jsPDF();
            doc.text(title, 14, 20);
            doc.autoTable({
                startY: 25,
                head: [headers.filter(header => header !== 'Actions')], // Exclude "Actions"
                body: rows, 
                theme: 'striped',
                headStyles: { fillColor: [26, 79, 50] }
            });
            doc.save(`${title}.pdf`);
            showCustomModal('Success', 'Document generated for printing (PDF).', false);
        } catch (error) {
            showCustomModal('Error', 'Failed to generate printable document: ' + error.message, false);
            console.error("Error printing table:", error); // Log detailed error
        } finally {
            loading(false);
        }
    }


    /********************
     * Views - Admin Side Management
     ********************/
    const viewHandlers = {
      dashboard: renderDashboard,
      students: renderStudentsAdmin,
      courses: renderCoursesAdmin,
      registrations: renderRegistrationsAdmin, // Student-like registrations but managed by admin
      fees: renderFeesAdmin,
      grades: renderGradesAdmin,
      hostels: renderHostelsAdmin,
      announcements: renderAnnouncementsAdmin,
      graduation: renderGraduationRequestsAdmin,
      clearance: renderClearanceRequestsAdmin,
      'admin-users': renderAdminUsers, // Corrected from 'admins' for consistency with data-view
      settings: renderSettingsAdmin,
    };

    // --- Dashboard ---
    async function renderDashboard() {
        showApp();
        main.innerHTML = `
            <div class="section-header">
                <div class="section-title"><i class="fa-solid fa-gauge"></i> Dashboard</div>
                <div>
                    <button class="btn" id="refreshDash"><i class="fa-solid fa-rotate"></i> Refresh</button>
                </div>
            </div>
            <div class="cards" id="dashCards">
                <div class="card"><h4>Total Students</h4><div class="value" id="statStudents">0</div><div class="muted">All-time</div></div>
                <div class="card"><h4>Total Courses</h4><div class="value" id="statCourses">0</div><div class="muted">Active</div></div>
                <div class="card"><h4>Registrations</h4><div class="value" id="statRegs">0</div><div class="muted">Current term</div></div>
                <div class="card"><h4>Pending Graduations</h4><div class="value" id="statPendingGrad">0</div><div class="muted">Requests</div></div>
                <div class="card"><h4>Pending Clearances</h4><div class="value" id="statPendingClearance">0</div><div class="muted">Requests</div></div>
                <div class="card"><h4>Hostel Applications</h4><div class="value" id="statHostelApps">0</div><div class="muted">Pending</div></div>
                <div class="card"><h4>Outstanding Fees</h4><div class="value" id="statOutstandingFees">GHS 0.00</div><div class="muted">Across all students</div></div>
            </div>
            <div style="height:14px"></div>
            <div class="card">
                <h4>Recent Registrations</h4>
                <table class="table" id="recentRegs">
                    <thead><tr><th>Student</th><th>Course</th><th>Date</th></tr></thead>
                    <tbody></tbody>
                </table>
                <div class="empty" id="recentRegsEmpty" style="display:none;">
                    <i class="fa-solid fa-database"></i>
                    <div>No recent registrations.</div>
                </div>
            </div>
        `;

        loading(true, 'Loading dashboard data...');
        try {
            const [studentsSnap, coursesSnap, regsSnap, gradSnap, clearanceSnap, hostelAppsSnap, feesSnap] = await Promise.all([
                getDocs(collection(db, 'students')),
                getDocs(collection(db, 'courses')),
                getDocs(query(collection(db, 'registrations'))), // All registrations
                getDocs(query(collection(db, 'graduationRequests'), where('status', '==', 'Pending'))),
                getDocs(query(collection(db, 'clearanceRequests'), where('status', '==', 'Pending'))),
                getDocs(query(collection(db, 'hostelApplications'), where('status', '==', 'Pending'))),
                getDocs(collection(db, 'fees')) // Get all fees documents to calculate outstanding
            ]);

            qs('#statStudents').textContent = studentsSnap.size;
            qs('#statCourses').textContent = coursesSnap.size;
            qs('#statRegs').textContent = regsSnap.size;
            qs('#statPendingGrad').textContent = gradSnap.size;
            qs('#statPendingClearance').textContent = clearanceSnap.size;
            qs('#statHostelApps').textContent = hostelAppsSnap.size;

            let totalOutstandingFees = 0;
            feesSnap.forEach(docSnap => {
                const data = docSnap.data();
                let currentBalance = data.totalFees || 0;
                const totalPayments = (data.payments || []).reduce((sum, p) => sum + p.amount, 0);
                currentBalance -= totalPayments;
                if (currentBalance > 0) {
                    totalOutstandingFees += currentBalance;
                }
            });
            qs('#statOutstandingFees').textContent = `GHS ${totalOutstandingFees.toFixed(2)}`;

            const tbody = qs('#recentRegs tbody');
            tbody.innerHTML = '';
            const recentRegistrations = regsSnap.docs
                .map(doc => ({ id: doc.id, ...doc.data() }))
                .sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0)) // Sort by createdAt desc
                .slice(0, 5); // Take top 5

            if (recentRegistrations.length === 0) {
                qs('#recentRegsEmpty').style.display = 'block';
            } else {
                qs('#recentRegsEmpty').style.display = 'none';
                recentRegistrations.forEach(r => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${escapeHtml(r.studentName || r.studentId || '—')}</td>
                                    <td>${escapeHtml(r.courseName || r.courseId || '—')}</td>
                                    <td>${fmtDate(r.createdAt)}</td>`;
                    tbody.appendChild(tr);
                });
            }
        } catch (err) {
            console.error('Dashboard load error', err);
            toast('Failed to load dashboard: ' + err.message);
        } finally {
            loading(false);
        }
        qs('#refreshDash').addEventListener('click', renderDashboard);
    }

    // --- Student Management (Admin) ---
    async function renderStudentsAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-user-graduate"></i> Students</div>
          <div>
            <button class="btn primary" id="addStudent"><i class="fa-solid fa-plus"></i> Add Student</button>
            <button class="btn" onclick="exportTable('studentsTable', 'Students_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
            <button class="btn" onclick="printTable('studentsTable', 'Students List')"><i class="fa-solid fa-print"></i> Print</button>
          </div>
        </div>
        <div class="card">
          <input type="text" id="studentSearchInput" placeholder="Search by name or email..." class="field-input" style="width:100%; margin-bottom:15px; padding:10px; border:1px solid #ddd; border-radius:8px;">
          <table class="table" id="studentsTable">
            <thead><tr><th>Name</th><th>Email</th><th>Program</th><th>Year</th><th>Contact</th><th></th></tr></thead>
            <tbody></tbody>
          </table>
          <div class="empty" id="studentsEmpty" style="display:none;">
            <i class="fa-solid fa-database"></i>
            <div>No students yet.</div>
            <small>Use “Add Student” to create one.</small>
          </div>
        </div>
      `;

      await loadStudentsAdmin();
      qs('#addStudent').addEventListener('click', addStudentDialog);
      qs('#studentSearchInput').addEventListener('input', () => loadStudentsAdmin(qs('#studentSearchInput').value));
    }

    async function loadStudentsAdmin(searchTerm = '') {
      loading(true, 'Loading student records...');
      try {
        const studentsRef = collection(db, 'students');
        let q = studentsRef;
        // No orderBy for search on multiple fields. Filter in memory for now.
        const snapshot = await getDocs(q);
        let students = snapshot.docs.map(doc => ({ uid: doc.id, ...doc.data() }));

        if (searchTerm) {
            const lowerSearchTerm = searchTerm.toLowerCase();
            students = students.filter(s =>
                (s.name && s.name.toLowerCase().includes(lowerSearchTerm)) ||
                (s.email && s.email.toLowerCase().includes(lowerSearchTerm)) ||
                (s.programme && s.programme.toLowerCase().includes(lowerSearchTerm)) ||
                (s.contact && s.contact.toLowerCase().includes(lowerSearchTerm))
            );
        }

        const columns = ['name', 'email', 'programme', 'year', 'contact'];
        const actions = [
            { text: 'Edit', class: '', handler: (student) => editStudentDialog(student.uid) },
            { text: 'Delete', class: 'secondary', handler: (student) => deleteStudent(student.uid) }
        ];

        renderTable('studentsTable', students, columns, actions);
        if (students.length === 0 && !searchTerm) {
            qs('#studentsEmpty').style.display = 'block';
        } else {
            qs('#studentsEmpty').style.display = 'none';
        }

      } catch (err) {
        console.error('Load students error', err);
        toast('Failed to load students: ' + err.message);
      } finally {
        loading(false);
      }
    }

    async function addStudentDialog() {
        const confirmed = await showCustomModal('Add New Student', `
            <div class="form-grid">
                <div class="field"><label>Name</label><input type="text" id="addStudentName" placeholder="Full Name" /></div>
                <div class="field"><label>Email</label><input type="email" id="addStudentEmail" placeholder="Email" /></div>
                <div class="field"><label>Password</label><input type="password" id="addStudentPassword" placeholder="Temporary Password" /></div>
                <div class="field"><label>Programme</label><input type="text" id="addStudentProgram" placeholder="Programme" /></div>
                <div class="field"><label>Year</label><input type="number" id="addStudentYear" placeholder="Year" /></div>
                <div class="field"><label>Contact</label><input type="text" id="addStudentContact" placeholder="Contact" /></div>
            </div>
            <p class="muted" style="margin-top:10px;">A temporary password will be set for the new student. They should change it upon first login.</p>
        `, true);

        if (confirmed) {
            const name = qs('#addStudentName').value;
            const email = qs('#addStudentEmail').value;
            const password = qs('#addStudentPassword').value;
            const programme = qs('#addStudentProgram').value;
            const year = parseInt(qs('#addStudentYear').value);
            const contact = qs('#addStudentContact').value;

            if (!name || !email || !password || !programme || isNaN(year) || !contact) {
                toast('All fields are required.');
                return;
            }
            if (password.length < 6) {
                toast('Password must be at least 6 characters.');
                return;
            }
            loading(true, 'Adding student...');
            try {
                // 1. Create user in Firebase Authentication
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const uid = userCredential.user.uid;

                // 2. Add student profile to Firestore using UID as document ID
                await setDoc(doc(db, 'students', uid), {
                    name, email, programme, year, contact,
                    regNo: 'Pending', // Assign a default, admin can update later
                    campus: 'Main Campus',
                    dob: 'N/A',
                    gender: 'N/A',
                    address: 'N/A',
                    profilePhotoURL: 'https://placehold.co/100x100/eeeeee/333333?text=Avatar',
                    createdAt: serverTimestamp(),
                    initialized: true
                });
                toast('Student added successfully!');
                loadStudentsAdmin();
            } catch (err) {
                console.error('Add student failed:', err);
                let errorMessage = 'Failed to add student.';
                if (err.code === 'auth/email-already-in-use') {
                    errorMessage = 'The email is already in use by another account.';
                }
                toast(errorMessage);
            } finally {
                loading(false);
            }
        }
    }

    async function editStudentDialog(uid) {
        loading(true, 'Fetching student data...');
        try {
            const studentRef = doc(db, 'students', uid);
            const studentSnap = await getDoc(studentRef);
            if (!studentSnap.exists()) {
                toast('Student not found.');
                loading(false);
                return;
            }
            const studentData = studentSnap.data();
            loading(false);

            const confirmed = await showCustomModal('Edit Student', `
                <div class="form-grid">
                    <div class="field"><label>Name</label><input type="text" id="editStudentName" value="${escapeHtml(studentData.name || '')}" /></div>
                    <div class="field"><label>Email</label><input type="email" id="editStudentEmail" value="${escapeHtml(studentData.email || '')}" disabled /></div>
                    <div class="field"><label>Registration No.</label><input type="text" id="editStudentRegNo" value="${escapeHtml(studentData.regNo || '')}" /></div>
                    <div class="field"><label>Programme</label><input type="text" id="editStudentProgram" value="${escapeHtml(studentData.programme || '')}" /></div>
                    <div class="field"><label>Year</label><input type="number" id="editStudentYear" value="${escapeHtml(String(studentData.year || ''))}" /></div>
                    <div class="field"><label>Contact</label><input type="text" id="editStudentContact" value="${escapeHtml(studentData.contact || '')}" /></div>
                    <div class="field"><label>Campus</label><input type="text" id="editStudentCampus" value="${escapeHtml(studentData.campus || '')}" /></div>
                    <div class="field"><label>Date of Birth</label><input type="date" id="editStudentDob" value="${escapeHtml(studentData.dob || '')}" /></div>
                    <div class="field"><label>Gender</label>
                        <select id="editStudentGender">
                            <option value="">Select</option>
                            <option value="Male" ${studentData.gender === 'Male' ? 'selected' : ''}>Male</option>
                            <option value="Female" ${studentData.gender === 'Female' ? 'selected' : ''}>Female</option>
                            <option value="Other" ${studentData.gender === 'Other' ? 'selected' : ''}>Other</option>
                        </select>
                    </div>
                    <div class="field"><label>Address</label><input type="text" id="editStudentAddress" value="${escapeHtml(studentData.address || '')}" /></div>
                </div>
            `, true);

            if (confirmed) {
                const updatedData = {
                    name: qs('#editStudentName').value,
                    regNo: qs('#editStudentRegNo').value,
                    programme: qs('#editStudentProgram').value,
                    year: parseInt(qs('#editStudentYear').value),
                    contact: qs('#editStudentContact').value,
                    campus: qs('#editStudentCampus').value,
                    dob: qs('#editStudentDob').value,
                    gender: qs('#editStudentGender').value,
                    address: qs('#editStudentAddress').value,
                };
                if (isNaN(updatedData.year)) {
                    toast('Year must be a number.'); return;
                }

                loading(true, 'Updating student...');
                await updateDoc(studentRef, updatedData);
                toast('Student updated!');
                loadStudentsAdmin();
            }
        } catch (err) {
            console.error('Edit student failed:', err);
            toast('Failed to edit student: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function deleteStudent(uid) {
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this student? This will delete their profile and potentially other related data.', true);
        if (confirmed) {
            loading(true, 'Deleting student...');
            try {
                // Delete student document
                await deleteDoc(doc(db, 'students', uid));
                // Delete associated records from 'fees', 'grades', 'registrations', 'hostelApplications', 'graduationRequests', 'clearanceRequests'
                // This would ideally be handled by Firebase Cloud Functions for robust cascade deletes,
                // but for client-side, we'll do a best-effort removal.

                const batch = db.batch();

                // Delete from 'fees'
                batch.delete(doc(db, 'fees', uid));
                // Delete from 'grades'
                batch.delete(doc(db, 'grades', uid));
                // Delete from 'registrations' (if uid is used as doc ID)
                batch.delete(doc(db, 'registrations', uid));
                // Delete from 'hostelApplications'
                batch.delete(doc(db, 'hostelApplications', uid));
                // Delete from 'graduationRequests'
                const gradRequestsSnap = await getDocs(query(collection(db, 'graduationRequests'), where('studentId', '==', uid)));
                gradRequestsSnap.forEach(d => batch.delete(d.ref));
                // Delete from 'clearanceRequests'
                const clearanceRequestsSnap = await getDocs(query(collection(db, 'clearanceRequests'), where('studentId', '==', uid)));
                clearanceRequestsSnap.forEach(d => batch.delete(d.ref));


                await batch.commit();

                // Note: Deleting the Firebase Authentication user is not possible from client-side without re-authentication.
                // For a complete solution, this would require an Admin SDK call via a Cloud Function.

                toast('Student and related data deleted!');
                loadStudentsAdmin();
            } catch (err) {
                console.error('Delete student failed:', err);
                toast('Failed to delete student: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }


    // --- Course Management (Admin) ---
    async function renderCoursesAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-book"></i> Courses</div>
          <div>
            <button class="btn primary" id="addCourse"><i class="fa-solid fa-plus"></i> Add Course</button>
            <button class="btn" onclick="exportTable('coursesTable', 'Courses_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
            <button class="btn" onclick="printTable('coursesTable', 'Courses List')"><i class="fa-solid fa-print"></i> Print</button>
          </div>
        </div>
        <div class="card">
          <input type="text" id="courseSearchInput" placeholder="Search by code, name, or lecturer..." class="field-input" style="width:100%; margin-bottom:15px; padding:10px; border:1px solid #ddd; border-radius:8px;">
          <table class="table" id="coursesTable">
            <thead><tr><th>Code</th><th>Name</th><th>Credits</th><th>Lecturer</th><th>Schedule</th><th></th></tr></thead>
            <tbody></tbody>
          </table>
          <div class="empty" id="coursesEmpty" style="display:none;">
            <i class="fa-solid fa-database"></i>
            <div>No courses yet.</div>
            <small>Use “Add Course” to create one.</small>
          </div>
        </div>
      `;

      await loadCoursesAdmin();
      qs('#addCourse').addEventListener('click', addCourseDialog);
      qs('#courseSearchInput').addEventListener('input', () => loadCoursesAdmin(qs('#courseSearchInput').value));
    }

    async function loadCoursesAdmin(searchTerm = '') {
      loading(true, 'Loading courses...');
      try {
        const coursesRef = collection(db, 'courses');
        const snapshot = await getDocs(coursesRef);
        let courses = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        if (searchTerm) {
            const lowerSearchTerm = searchTerm.toLowerCase();
            courses = courses.filter(c =>
                (c.courseCode && c.courseCode.toLowerCase().includes(lowerSearchTerm)) ||
                (c.courseName && c.courseName.toLowerCase().includes(lowerSearchTerm)) ||
                (c.lecturer && c.lecturer.toLowerCase().includes(lowerSearchTerm))
            );
        }

        const columns = ['courseCode', 'courseName', 'credits', 'lecturer', 'schedule'];
        const actions = [
            { text: 'Edit', class: '', handler: (course) => editCourseDialog(course.id) },
            { text: 'Delete', class: 'secondary', handler: (course) => deleteCourse(course.id) }
        ];

        renderTable('coursesTable', courses, columns, actions);
        if (courses.length === 0 && !searchTerm) {
            qs('#coursesEmpty').style.display = 'block';
        } else {
            qs('#coursesEmpty').style.display = 'none';
        }
      } catch (err) {
        console.error('Load courses error', err);
        toast('Failed to load courses: ' + err.message);
      } finally {
        loading(false);
      }
    }

    async function addCourseDialog() {
        const confirmed = await showCustomModal('Add New Course', `
            <div class="form-grid">
                <div class="field"><label>Course Code</label><input type="text" id="addCourseCode" placeholder="e.g., DES101" /></div>
                <div class="field"><label>Course Name</label><input type="text" id="addCourseName" placeholder="e.g., Intro to Design" /></div>
                <div class="field"><label>Credits</label><input type="number" id="addCourseCredits" placeholder="e.g., 3" /></div>
                <div class="field"><label>Lecturer</label><input type="text" id="addCourseLecturer" placeholder="e.g., Dr. Jane Doe" /></div>
                <div class="field"><label>Schedule</label><input type="text" id="addCourseSchedule" placeholder="e.g., Mon 10:00-12:00" /></div>
            </div>
        `, true);

        if (confirmed) {
            const code = qs('#addCourseCode').value;
            const name = qs('#addCourseName').value;
            const credits = parseInt(qs('#addCourseCredits').value);
            const lecturer = qs('#addCourseLecturer').value;
            const schedule = qs('#addCourseSchedule').value;

            if (!code || !name || isNaN(credits) || !lecturer || !schedule) {
                toast('All fields are required.');
                return;
            }
            loading(true, 'Adding course...');
            try {
                // Use addDoc to let Firestore auto-generate ID for 'courses' collection
                await addDoc(collection(db, 'courses'), {
                    courseCode: code,
                    courseName: name,
                    credits: credits,
                    lecturer: lecturer,
                    schedule: schedule,
                    createdAt: serverTimestamp()
                });
                toast('Course added successfully!');
                loadCoursesAdmin();
            } catch (err) {
                console.error('Add course failed:', err);
                toast('Failed to add course: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    async function editCourseDialog(id) {
        loading(true, 'Fetching course data...');
        try {
            const courseRef = doc(db, 'courses', id);
            const courseSnap = await getDoc(courseRef);
            if (!courseSnap.exists()) {
                toast('Course not found.');
                loading(false);
                return;
            }
            const courseData = courseSnap.data();
            loading(false);

            const confirmed = await showCustomModal('Edit Course', `
                <div class="form-grid">
                    <div class="field"><label>Course Code</label><input type="text" id="editCourseCode" value="${escapeHtml(courseData.courseCode || '')}" /></div>
                    <div class="field"><label>Course Name</label><input type="text" id="editCourseName" value="${escapeHtml(courseData.courseName || '')}" /></div>
                    <div class="field"><label>Credits</label><input type="number" id="editCourseCredits" value="${escapeHtml(String(courseData.credits || ''))}" /></div>
                    <div class="field"><label>Lecturer</label><input type="text" id="editCourseLecturer" value="${escapeHtml(courseData.lecturer || '')}" /></div>
                    <div class="field"><label>Schedule</label><input type="text" id="editCourseSchedule" value="${escapeHtml(courseData.schedule || '')}" /></div>
                </div>
            `, true);

            if (confirmed) {
                const updatedData = {
                    courseCode: qs('#editCourseCode').value,
                    courseName: qs('#editCourseName').value,
                    credits: parseInt(qs('#editCourseCredits').value),
                    lecturer: qs('#editCourseLecturer').value,
                    schedule: qs('#editCourseSchedule').value,
                };
                if (isNaN(updatedData.credits)) {
                    toast('Credits must be a number.'); return;
                }
                if (!updatedData.courseCode || !updatedData.courseName || !updatedData.lecturer || !updatedData.schedule) {
                    toast('All fields are required.'); return;
                }

                loading(true, 'Updating course...');
                await updateDoc(courseRef, updatedData);
                toast('Course updated!');
                loadCoursesAdmin();
            }
        } catch (err) {
            console.error('Edit course failed:', err);
            toast('Failed to edit course: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function deleteCourse(id) {
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this course? This action cannot be undone and may affect student registrations.', true);
        if (confirmed) {
            loading(true, 'Deleting course...');
            try {
                await deleteDoc(doc(db, 'courses', id));
                toast('Course deleted!');
                loadCoursesAdmin();
            } catch (err) {
                console.error('Delete course failed:', err);
                toast('Failed to delete course: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Registrations Management (Admin) ---
    async function renderRegistrationsAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-clipboard-list"></i> Registrations</div>
          <div>
            <button class="btn primary" id="addRegistration"><i class="fa-solid fa-plus"></i> Add Registration</button>
            <button class="btn" onclick="exportTable('registrationsTable', 'Registrations_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
            <button class="btn" onclick="printTable('registrationsTable', 'Registrations List')"><i class="fa-solid fa-print"></i> Print</button>
          </div>
        </div>
        <div class="card">
            <input type="text" id="registrationSearchInput" placeholder="Search by student or course..." class="field-input" style="width:100%; margin-bottom:15px; padding:10px; border:1px solid #ddd; border-radius:8px;">
            <table class="table" id="registrationsTable">
                <thead><tr><th>Student Name</th><th>Course Name</th><th>Registration Date</th><th>Status</th><th></th></tr></thead>
                <tbody></tbody>
            </table>
            <div class="empty" id="registrationsEmpty" style="display:none;">
                <i class="fa-solid fa-database"></i>
                <div>No registrations yet.</div>
                <small>Use “Add Registration” to create one.</small>
            </div>
        </div>
      `;
      await loadRegistrationsAdmin();
      qs('#addRegistration').addEventListener('click', addRegistrationDialog);
      qs('#registrationSearchInput').addEventListener('input', () => loadRegistrationsAdmin(qs('#registrationSearchInput').value));
    }

    async function loadRegistrationsAdmin(searchTerm = '') {
        loading(true, 'Loading registrations...');
        try {
            const registrationsCollectionRef = collection(db, 'registrations');
            const studentsCollectionRef = collection(db, 'students');
            const coursesCollectionRef = collection(db, 'courses');

            const allRegistrationsSnap = await getDocs(registrationsCollectionRef);
            const allStudentsSnap = await getDocs(studentsCollectionRef);
            const allCoursesSnap = await getDocs(coursesCollectionRef);

            const studentsMap = new Map(allStudentsSnap.docs.map(doc => [doc.id, doc.data()]));
            const coursesMap = new Map(allCoursesSnap.docs.map(doc => [doc.id, doc.data()]));

            let registrations = [];
            allRegistrationsSnap.forEach(docSnap => {
                const data = docSnap.data();
                // If a student's main registration document, it contains an array of courses
                if (data.courses && Array.isArray(data.courses)) {
                    data.courses.forEach(courseReg => {
                        registrations.push({
                            id: docSnap.id + '-' + courseReg.id, // Unique ID for each course registration entry
                            studentId: docSnap.id,
                            studentName: studentsMap.get(docSnap.id)?.name || 'Unknown Student',
                            courseId: courseReg.id,
                            courseName: courseReg.courseName,
                            registrationDate: courseReg.registrationDate,
                            status: courseReg.status || 'Registered' // Default status
                        });
                    });
                }
            });

            if (searchTerm) {
                const lowerSearchTerm = searchTerm.toLowerCase();
                registrations = registrations.filter(r =>
                    r.studentName.toLowerCase().includes(lowerSearchTerm) ||
                    r.courseName.toLowerCase().includes(lowerSearchTerm)
                );
            }
            // Sort by registration date, newest first
            registrations.sort((a, b) => new Date(b.registrationDate) - new Date(a.registrationDate));

            const columns = ['studentName', 'courseName', 'registrationDate', 'status'];
            const actions = [
                { text: 'Delete', class: 'secondary', handler: (reg) => deleteRegistration(reg.studentId, reg.courseId) } // Pass studentId and courseId
            ];

            renderTable('registrationsTable', registrations, columns, actions);
            if (registrations.length === 0 && !searchTerm) {
                qs('#registrationsEmpty').style.display = 'block';
            } else {
                qs('#registrationsEmpty').style.display = 'none';
            }

        } catch (err) {
            console.error('Load registrations error', err);
            toast('Failed to load registrations: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function addRegistrationDialog() {
        loading(true, 'Fetching students and courses...');
        try {
            const studentsSnap = await getDocs(collection(db, 'students'));
            const coursesSnap = await getDocs(collection(db, 'courses'));
            
            const students = studentsSnap.docs.map(doc => ({ uid: doc.id, name: doc.data().name, email: doc.data().email }));
            const courses = coursesSnap.docs.map(doc => ({ id: doc.id, code: doc.data().courseCode, name: doc.data().courseName }));

            if (students.length === 0 || courses.length === 0) {
                toast('No students or courses available to register.');
                loading(false);
                return;
            }
            loading(false);

            const studentOptions = students.map(s => `<option value="${s.uid}">${s.name} (${s.email})</option>`).join('');
            const courseOptions = courses.map(c => `<option value="${c.id}">${c.code} - ${c.name}</option>`).join('');

            const confirmed = await showCustomModal('Add New Registration', `
                <div class="form-grid">
                    <div class="field"><label>Student</label>
                        <select id="addRegStudentId">${studentOptions}</select>
                    </div>
                    <div class="field"><label>Course</label>
                        <select id="addRegCourseId">${courseOptions}</select>
                    </div>
                </div>
            `, true);

            if (confirmed) {
                const studentId = qs('#addRegStudentId').value;
                const courseId = qs('#addRegCourseId').value;
                
                loading(true, 'Creating registration...');
                try {
                    const studentData = students.find(s => s.uid === studentId);
                    const courseData = courses.find(c => c.id === courseId);

                    if (!studentData || !courseData) {
                        toast('Invalid student or course selected.');
                        return;
                    }

                    const registrationDocRef = doc(db, 'registrations', studentId);
                    
                    const newCourseEntry = {
                        id: courseId,
                        courseCode: courseData.code,
                        courseName: courseData.name,
                        registrationDate: new Date().toISOString(),
                        status: 'Registered'
                    };

                    // Use arrayUnion to add the course to the student's courses array
                    await updateDoc(registrationDocRef, {
                        courses: arrayUnion(newCourseEntry)
                    }, { merge: true }); // Use merge to create if not exists, or update

                    toast('Registration added successfully!');
                    loadRegistrationsAdmin();
                } catch (err) {
                    console.error('Add registration failed:', err);
                    toast('Failed to add registration: ' + err.message);
                } finally {
                    loading(false);
                }
            }
        } catch (err) {
            console.error('Add registration dialog failed:', err);
            toast('Failed to prepare registration form: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function deleteRegistration(studentId, courseId) {
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this course registration?', true);
        if (confirmed) {
            loading(true, 'Deleting registration...');
            try {
                const registrationDocRef = doc(db, 'registrations', studentId);
                const registrationSnap = await getDoc(registrationDocRef);
                
                if (registrationSnap.exists()) {
                    const courses = registrationSnap.data().courses || [];
                    const courseToRemove = courses.find(c => c.id === courseId); // Find by course document ID
                    
                    if (courseToRemove) {
                        await updateDoc(registrationDocRef, {
                            courses: arrayRemove(courseToRemove)
                        });
                        toast('Registration deleted!');
                        loadRegistrationsAdmin();
                    } else {
                        toast('Registration not found for specified course.');
                    }
                } else {
                    toast('Student registration record not found.');
                }
            } catch (err) {
                console.error('Delete registration failed:', err);
                toast('Failed to delete registration: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Fees Management (Admin) ---
    async function renderFeesAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-money-bill-wave"></i> Fees Management</div>
        </div>
        <div class="card">
          <div class="form-grid" style="grid-template-columns: 1fr auto;">
            <div class="field"><label>Student Email / ID</label><input type="text" id="feesSearchStudent" placeholder="Enter student email or ID" /></div>
            <button class="btn primary" id="searchFeesStudentBtn" style="align-self: flex-end;"><i class="fa-solid fa-search"></i> Search</button>
          </div>
          <div id="feesStudentInfo" style="margin-top:20px; display:none;">
            <h3 style="font-size:1.1rem; font-weight:600; margin-bottom:10px;">Fees for: <span id="feesStudentName"></span> (<span id="feesStudentEmail"></span>)</h3>
            <div class="form-grid" style="margin-bottom:15px;">
                <div class="field"><label>Total Fees Charged (GHS)</label><input type="number" id="totalFeesCharged" step="0.01" value="0.00" /></div>
                <button class="btn primary" id="updateTotalFeesBtn" style="align-self: flex-end;">Update Total Fees</button>
            </div>
            <div class="section-header">
                <h4 style="font-size:1rem; font-weight:600;">Fee Transactions</h4>
                <button class="btn" id="addFeeTransactionBtn"><i class="fa-solid fa-plus"></i> Add Transaction</button>
            </div>
            <table class="table" id="feesTransactionsTable">
                <thead><tr><th>Date</th><th>Description</th><th>Amount (GHS)</th><th>Type</th><th></th></tr></thead>
                <tbody></tbody>
            </table>
            <div class="empty" id="feesTransactionsEmpty" style="display:none;">
                <i class="fa-solid fa-database"></i>
                <div>No transactions yet.</div>
            </div>
            <div style="margin-top:20px; text-align:right;">
                <h3 style="font-size:1.2rem; font-weight:700;">Current Balance: <span id="currentFeesBalance" style="color:red;">GHS 0.00</span></h3>
            </div>
             <div class="actions-cell" style="margin-top:15px; text-align:right;">
                <button class="btn" onclick="exportTable('feesTransactionsTable', 'Fees_Statement')"><i class="fa-solid fa-file-export"></i> Export</button>
                <button class="btn" onclick="printTable('feesTransactionsTable', 'Student Fees Statement')"><i class="fa-solid fa-print"></i> Print</button>
             </div>
          </div>
        </div>
      `;

      qs('#searchFeesStudentBtn').addEventListener('click', searchStudentForFeesAdmin);
      qs('#updateTotalFeesBtn').addEventListener('click', updateStudentTotalFees);
      qs('#addFeeTransactionBtn').addEventListener('click', addFeeTransactionDialog);
    }

    async function searchStudentForFeesAdmin() {
        const searchTerm = qs('#feesSearchStudent').value.trim();
        if (!searchTerm) {
            toast('Please enter a student email or ID.');
            return;
        }
        loading(true, 'Searching student for fees...');
        try {
            const studentsRef = collection(db, 'students');
            const q = query(studentsRef, where('email', '==', searchTerm));
            const snapshot = await getDocs(q);

            let studentDoc = null;
            if (!snapshot.empty) {
                studentDoc = snapshot.docs[0];
            } else {
                // Try searching by UID if not found by email
                const studentByIdSnap = await getDoc(doc(db, 'students', searchTerm));
                if (studentByIdSnap.exists()) {
                    studentDoc = studentByIdSnap;
                }
            }

            if (!studentDoc) {
                qs('#feesStudentInfo').style.display = 'none';
                toast('Student not found.');
                currentAdminStudentId = null;
                return;
            }

            const studentData = studentDoc.data();
            currentAdminStudentId = studentDoc.id; // Store for future operations

            qs('#feesStudentName').textContent = studentData.name || 'N/A';
            qs('#feesStudentEmail').textContent = studentData.email || 'N/A';

            // Load fee data for this student
            const feesDocRef = doc(db, 'fees', currentAdminStudentId);
            const feesSnap = await getDoc(feesDocRef);
            let feesData = { totalFees: 0, payments: [] };
            if (feesSnap.exists()) {
                feesData = feesSnap.data();
            } else {
                // Initialize fees document if it doesn't exist
                await setDoc(feesDocRef, feesData);
            }

            qs('#totalFeesCharged').value = (feesData.totalFees || 0).toFixed(2);
            renderFeesTransactions(feesData.payments || []);
            calculateAndDisplayBalance(feesData);

            qs('#feesStudentInfo').style.display = 'block';

        } catch (err) {
            console.error('Search student for fees failed:', err);
            toast('Failed to search student for fees: ' + err.message);
        } finally {
            loading(false);
        }
    }

    function renderFeesTransactions(payments) {
        // Sort payments by date to ensure correct order
        payments.sort((a, b) => new Date(a.date) - new Date(b.date));

        const columns = ['date', 'description', 'amount', 'type'];
        const actions = [
            { text: 'Delete', class: 'secondary', handler: (item) => deleteFeeTransaction(item.date, item.amount, item.type) }
        ];
        renderTable('feesTransactionsTable', payments, columns, actions);
        if (payments.length === 0) {
            qs('#feesTransactionsEmpty').style.display = 'block';
        } else {
            qs('#feesTransactionsEmpty').style.display = 'none';
        }
    }

    function calculateAndDisplayBalance(feesData) {
        let totalPayments = (feesData.payments || []).filter(p => p.type === 'payment').reduce((sum, p) => sum + p.amount, 0);
        let totalCharges = (feesData.payments || []).filter(p => p.type === 'charge').reduce((sum, p) => sum + p.amount, 0);

        const balance = (feesData.totalFees || 0) + totalCharges - totalPayments;
        qs('#currentFeesBalance').textContent = `GHS ${balance.toFixed(2)}`;
        qs('#currentFeesBalance').style.color = balance > 0 ? 'red' : 'green';
    }

    async function updateStudentTotalFees() {
        if (!currentAdminStudentId) {
            toast('Please search for a student first.');
            return;
        }
        const newTotalFees = parseFloat(qs('#totalFeesCharged').value);
        if (isNaN(newTotalFees) || newTotalFees < 0) {
            toast('Please enter a valid total fees amount.');
            return;
        }

        loading(true, 'Updating total fees...');
        try {
            const feesDocRef = doc(db, 'fees', currentAdminStudentId);
            await updateDoc(feesDocRef, { totalFees: newTotalFees });
            toast('Total fees updated!');
            searchStudentForFeesAdmin(); // Reload to update balance
        } catch (err) {
            console.error('Update total fees failed:', err);
            toast('Failed to update total fees: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function addFeeTransactionDialog() {
        if (!currentAdminStudentId) {
            toast('Please search for a student first.');
            return;
        }
        const confirmed = await showCustomModal('Add New Transaction', `
            <div class="form-grid">
                <div class="field"><label>Amount (GHS)</label><input type="number" id="transactionAmount" step="0.01" placeholder="e.g., 500.00" /></div>
                <div class="field"><label>Description</label><input type="text" id="transactionDescription" placeholder="e.g., Tuition Payment, Late Fee" /></div>
                <div class="field"><label>Type</label>
                    <select id="transactionType">
                        <option value="payment">Payment</option>
                        <option value="charge">Charge</option>
                    </select>
                </div>
            </div>
        `, true);

        if (confirmed) {
            const amount = parseFloat(qs('#transactionAmount').value);
            const description = qs('#transactionDescription').value;
            const type = qs('#transactionType').value;

            if (isNaN(amount) || amount <= 0 || !description) {
                toast('Please enter a valid amount and description.');
                return;
            }
            loading(true, 'Adding transaction...');
            try {
                const feesDocRef = doc(db, 'fees', currentAdminStudentId);
                const newTransaction = {
                    date: new Date().toISOString(),
                    description,
                    amount,
                    type
                };
                await updateDoc(feesDocRef, { payments: arrayUnion(newTransaction) });
                toast('Transaction added!');
                searchStudentForFeesAdmin(); // Reload to update table and balance
            } catch (err) {
                console.error('Add transaction failed:', err);
                toast('Failed to add transaction: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    async function deleteFeeTransaction(date, amount, type) {
        if (!currentAdminStudentId) {
            toast('No student selected.');
            return;
        }
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this transaction?', true);
        if (confirmed) {
            loading(true, 'Deleting transaction...');
            try {
                const feesDocRef = doc(db, 'fees', currentAdminStudentId);
                const transactionToRemove = { date, amount, type }; // Reconstruct the exact object to remove
                await updateDoc(feesDocRef, { payments: arrayRemove(transactionToRemove) });
                toast('Transaction deleted!');
                searchStudentForFeesAdmin(); // Reload
            } catch (err) {
                console.error('Delete transaction failed:', err);
                toast('Failed to delete transaction: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Grades Management (Admin) ---
    async function renderGradesAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-award"></i> Grades Management</div>
        </div>
        <div class="card">
          <div class="form-grid" style="grid-template-columns: 1fr auto;">
            <div class="field"><label>Student Email / ID</label><input type="text" id="gradesSearchStudent" placeholder="Enter student email or ID" /></div>
            <button class="btn primary" id="searchGradesStudentBtn" style="align-self: flex-end;"><i class="fa-solid fa-search"></i> Search</button>
          </div>
          <div id="gradesStudentInfo" style="margin-top:20px; display:none;">
            <h3 style="font-size:1.1rem; font-weight:600; margin-bottom:10px;">Grades for: <span id="gradesStudentName"></span> (<span id="gradesStudentEmail"></span>)</h3>
            <div class="section-header">
                <h4 style="font-size:1rem; font-weight:600;">Recorded Grades</h4>
                <button class="btn" id="addGradeBtn"><i class="fa-solid fa-plus"></i> Add Grade</button>
            </div>
            <table class="table" id="gradesTable">
                <thead><tr><th>Course Code</th><th>Course Name</th><th>Grade</th><th>Credit Unit</th><th>Remarks</th><th></th></tr></thead>
                <tbody></tbody>
            </table>
            <div class="empty" id="gradesEmpty" style="display:none;">
                <i class="fa-solid fa-database"></i>
                <div>No grades recorded yet.</div>
            </div>
            <div style="margin-top:20px; text-align:right;">
                <h3 style="font-size:1.2rem; font-weight:700;">Current GPA: <span id="currentStudentGPA">0.00</span></h3>
            </div>
             <div class="actions-cell" style="margin-top:15px; text-align:right;">
                <button class="btn" onclick="exportTable('gradesTable', 'Grades_Report')"><i class="fa-solid fa-file-export"></i> Export</button>
                <button class="btn" onclick="printTable('gradesTable', 'Student Grades Report')"><i class="fa-solid fa-print"></i> Print</button>
             </div>
          </div>
        </div>
      `;

      qs('#searchGradesStudentBtn').addEventListener('click', searchStudentForGradesAdmin);
      qs('#addGradeBtn').addEventListener('click', addGradeDialog);
    }

    async function searchStudentForGradesAdmin() {
        const searchTerm = qs('#gradesSearchStudent').value.trim();
        if (!searchTerm) {
            toast('Please enter a student email or ID.');
            return;
        }
        loading(true, 'Searching student for grades...');
        try {
            const studentsRef = collection(db, 'students');
            const q = query(studentsRef, where('email', '==', searchTerm));
            const snapshot = await getDocs(q);

            let studentDoc = null;
            if (!snapshot.empty) {
                studentDoc = snapshot.docs[0];
            } else {
                const studentByIdSnap = await getDoc(doc(db, 'students', searchTerm));
                if (studentByIdSnap.exists()) {
                    studentDoc = studentByIdSnap;
                }
            }

            if (!studentDoc) {
                qs('#gradesStudentInfo').style.display = 'none';
                toast('Student not found.');
                currentAdminStudentId = null;
                return;
            }

            const studentData = studentDoc.data();
            currentAdminStudentId = studentDoc.id;

            qs('#gradesStudentName').textContent = studentData.name || 'N/A';
            qs('#gradesStudentEmail').textContent = studentData.email || 'N/A';

            await loadGradesForStudent(currentAdminStudentId);
            qs('#gradesStudentInfo').style.display = 'block';

        } catch (err) {
            console.error('Search student for grades failed:', err);
            toast('Failed to search student for grades: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function loadGradesForStudent(studentId) {
        loading(true, 'Loading grades...');
        try {
            const gradesRef = collection(db, 'grades');
            const q = query(gradesRef, where('studentId', '==', studentId));
            const snapshot = await getDocs(q);
            const grades = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            const columns = ['courseCode', 'courseName', 'grade', 'courseUnit', 'remarks'];
            const actions = [
                { text: 'Edit', class: '', handler: (grade) => editGradeDialog(grade.id) },
                { text: 'Delete', class: 'secondary', handler: (grade) => deleteGrade(grade.id) }
            ];
            renderTable('gradesTable', grades, columns, actions);
            if (grades.length === 0) {
                qs('#gradesEmpty').style.display = 'block';
            } else {
                qs('#gradesEmpty').style.display = 'none';
            }
            qs('#currentStudentGPA').textContent = calculateGPA(grades);

        } catch (err) {
            console.error('Load grades for student failed:', err);
            toast('Failed to load grades: ' + err.message);
        } finally {
            loading(false);
        }
    }

    // Helper for GPA calculation (can be placed outside, or within a utility object)
    function calculateGPA(grades) {
        let totalPoints = 0;
        let totalUnits = 0;
        const gradeMap = { 'A': 4.0, 'B': 3.0, 'C': 2.0, 'D': 1.0, 'F': 0.0 }; // Standard 4.0 scale
        grades.forEach(g => {
            const courseUnit = g.courseUnit || 3; // Default to 3 if not specified
            const gradePoint = gradeMap[g.grade ? g.grade.toUpperCase() : ''] || 0;
            totalPoints += gradePoint * courseUnit;
            totalUnits += courseUnit;
        });
        return totalUnits > 0 ? (totalPoints / totalUnits).toFixed(2) : "0.00";
    }

    async function addGradeDialog() {
        if (!currentAdminStudentId) {
            toast('Please search for a student first.');
            return;
        }

        loading(true, 'Fetching courses...');
        const coursesSnap = await getDocs(collection(db, 'courses'));
        const courses = coursesSnap.docs.map(doc => ({ id: doc.id, code: doc.data().courseCode, name: doc.data().courseName }));
        loading(false);

        if (courses.length === 0) {
            toast('No courses available to add grades for.');
            return;
        }

        const courseOptions = courses.map(c => `<option value="${c.id}">${c.code} - ${c.name}</option>`).join('');

        const confirmed = await showCustomModal('Add New Grade', `
            <div class="form-grid">
                <div class="field"><label>Course</label>
                    <select id="addGradeCourseId">${courseOptions}</select>
                </div>
                <div class="field"><label>Grade (A-F)</label><input type="text" id="addGradeValue" placeholder="e.g., A, B+, C" maxlength="2" style="text-transform:uppercase;" /></div>
                <div class="field"><label>Credit Unit</label><input type="number" id="addGradeUnit" placeholder="e.g., 3" value="3" /></div>
                <div class="field" style="grid-column: 1 / -1;"><label>Remarks (Optional)</label><textarea id="addGradeRemarks" rows="2"></textarea></div>
            </div>
        `, true);

        if (confirmed) {
            const courseId = qs('#addGradeCourseId').value;
            const grade = qs('#addGradeValue').value.toUpperCase().trim();
            const courseUnit = parseInt(qs('#addGradeUnit').value);
            const remarks = qs('#addGradeRemarks').value.trim();

            if (!courseId || !grade || isNaN(courseUnit) || courseUnit <= 0) {
                toast('Please fill all required fields correctly.');
                return;
            }
            if (!['A', 'B', 'C', 'D', 'F'].includes(grade.charAt(0)) && !['A+', 'A-', 'B+', 'B-', 'C+', 'C-'].includes(grade)) {
                toast('Invalid grade format. Use A, B, C, D, F, or with +/-.');
                return;
            }

            loading(true, 'Adding grade...');
            try {
                const courseData = courses.find(c => c.id === courseId);
                await addDoc(collection(db, 'grades'), {
                    studentId: currentAdminStudentId,
                    courseId: courseId,
                    courseCode: courseData.code,
                    courseName: courseData.name,
                    grade: grade,
                    courseUnit: courseUnit,
                    remarks: remarks,
                    recordedAt: serverTimestamp()
                });
                toast('Grade added successfully!');
                loadGradesForStudent(currentAdminStudentId);
            } catch (err) {
                console.error('Add grade failed:', err);
                toast('Failed to add grade: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    async function editGradeDialog(gradeId) {
        loading(true, 'Fetching grade data...');
        try {
            const gradeRef = doc(db, 'grades', gradeId);
            const gradeSnap = await getDoc(gradeRef);
            if (!gradeSnap.exists()) {
                toast('Grade record not found.');
                loading(false);
                return;
            }
            const gradeData = gradeSnap.data();
            loading(false);

            const confirmed = await showCustomModal('Edit Grade', `
                <div class="form-grid">
                    <div class="field"><label>Course</label><input type="text" value="${escapeHtml(gradeData.courseCode + ' - ' + gradeData.courseName)}" disabled /></div>
                    <div class="field"><label>Grade (A-F)</label><input type="text" id="editGradeValue" value="${escapeHtml(gradeData.grade || '')}" maxlength="2" style="text-transform:uppercase;" /></div>
                    <div class="field"><label>Credit Unit</label><input type="number" id="editGradeUnit" value="${escapeHtml(String(gradeData.courseUnit || ''))}" /></div>
                    <div class="field" style="grid-column: 1 / -1;"><label>Remarks (Optional)</label><textarea id="editGradeRemarks" rows="2">${escapeHtml(gradeData.remarks || '')}</textarea></div>
                </div>
            `, true);

            if (confirmed) {
                const grade = qs('#editGradeValue').value.toUpperCase().trim();
                const courseUnit = parseInt(qs('#editGradeUnit').value);
                const remarks = qs('#editGradeRemarks').value.trim();

                if (!grade || isNaN(courseUnit) || courseUnit <= 0) {
                    toast('Please fill all required fields correctly.');
                    return;
                }
                if (!['A', 'B', 'C', 'D', 'F'].includes(grade.charAt(0)) && !['A+', 'A-', 'B+', 'B-', 'C+', 'C-'].includes(grade)) {
                    toast('Invalid grade format. Use A, B, C, D, F, or with +/-.');
                    return;
                }

                loading(true, 'Updating grade...');
                await updateDoc(gradeRef, {
                    grade: grade,
                    courseUnit: courseUnit,
                    remarks: remarks
                });
                toast('Grade updated successfully!');
                loadGradesForStudent(currentAdminStudentId);
            }
        } catch (err) {
            console.error('Edit grade failed:', err);
            toast('Failed to edit grade: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function deleteGrade(gradeId) {
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this grade record?', true);
        if (confirmed) {
            loading(true, 'Deleting grade...');
            try {
                await deleteDoc(doc(db, 'grades', gradeId));
                toast('Grade deleted!');
                loadGradesForStudent(currentAdminStudentId);
            } catch (err) {
                console.error('Delete grade failed:', err);
                toast('Failed to delete grade: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }


    // --- Hostel Management (Admin) ---
    async function renderHostelsAdmin() {
        showApp();
        main.innerHTML = `
            <div class="section-header">
                <div class="section-title"><i class="fa-solid fa-building"></i> Hostel Management</div>
                <div>
                    <button class="btn primary" id="addHostelBtn"><i class="fa-solid fa-plus"></i> Add Hostel</button>
                    <button class="btn" id="toggleHostelAppsBtn"><i class="fa-solid fa-toggle-on"></i> Toggle Applications</button>
                    <button class="btn" onclick="exportTable('hostelsTable', 'Hostel_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
                    <button class="btn" onclick="printTable('hostelsTable', 'Hostel List')"><i class="fa-solid fa-print"></i> Print</button>
                </div>
            </div>
            <div class="card">
                <h4 style="font-size:1rem; font-weight:600; margin-bottom:10px;">Available Hostels</h4>
                <table class="table" id="hostelsTable">
                    <thead><tr><th>Name</th><th>Capacity</th><th>Available Rooms</th><th>Price (GHS)</th><th></th></tr></thead>
                    <tbody></tbody>
                </table>
                <div class="empty" id="hostelsEmpty" style="display:none;">
                    <i class="fa-solid fa-database"></i>
                    <div>No hostels defined yet.</div>
                    <small>Use “Add Hostel” to create one.</small>
                </div>
            </div>
            <div style="height:14px"></div>
            <div class="card">
                <h4 style="font-size:1rem; font-weight:600; margin-bottom:10px;">Hostel Applications</h4>
                <input type="text" id="hostelAppSearchInput" placeholder="Search applications by student name/email..." class="field-input" style="width:100%; margin-bottom:15px; padding:10px; border:1px solid #ddd; border-radius:8px;">
                <table class="table" id="hostelApplicationsTable">
                    <thead><tr><th>Student Name</th><th>Hostel Applied</th><th>Application Date</th><th>Status</th><th></th></tr></thead>
                    <tbody></tbody>
                </table>
                <div class="empty" id="hostelApplicationsEmpty" style="display:none;">
                    <i class="fa-solid fa-database"></i>
                    <div>No hostel applications yet.</div>
                </div>
            </div>
        `;
        await loadHostelsAdmin();
        await loadHostelApplicationsAdmin();
        qs('#addHostelBtn').addEventListener('click', addHostelDialog);
        qs('#toggleHostelAppsBtn').addEventListener('click', toggleHostelApplicationsStatus);
        qs('#hostelAppSearchInput').addEventListener('input', () => loadHostelApplicationsAdmin(qs('#hostelAppSearchInput').value));
    }

    async function loadHostelsAdmin() {
        loading(true, 'Loading hostels...');
        try {
            const hostelsRef = collection(db, 'hostels');
            const snapshot = await getDocs(hostelsRef);
            const hostels = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            const columns = ['name', 'capacity', 'spacesAvailable', 'price'];
            const actions = [
                { text: 'Edit', class: '', handler: (hostel) => editHostelDialog(hostel.id) },
                { text: 'Delete', class: 'secondary', handler: (hostel) => deleteHostel(hostel.id) }
            ];

            renderTable('hostelsTable', hostels, columns, actions);
            if (hostels.length === 0) {
                qs('#hostelsEmpty').style.display = 'block';
            } else {
                qs('#hostelsEmpty').style.display = 'none';
            }
            // Update toggle button text immediately after loading
            await updateToggleHostelButtonText();
        } catch (err) {
            console.error('Load hostels failed:', err);
            toast('Failed to load hostels: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function addHostelDialog() {
        const confirmed = await showCustomModal('Add New Hostel', `
            <div class="form-grid">
                <div class="field"><label>Hostel Name</label><input type="text" id="addHostelName" placeholder="e.g., Green Towers" /></div>
                <div class="field"><label>Total Capacity</label><input type="number" id="addHostelCapacity" placeholder="e.g., 100" /></div>
                <div class="field"><label>Available Rooms</label><input type="number" id="addHostelAvailable" placeholder="e.g., 50" /></div>
                <div class="field"><label>Price Per Semester (GHS)</label><input type="number" id="addHostelPrice" step="0.01" placeholder="e.g., 2500.00" /></div>
                <div class="field" style="grid-column: 1 / -1;"><label>Description</label><textarea id="addHostelDescription" rows="3" placeholder="Brief description of the hostel"></textarea></div>
            </div>
        `, true);

        if (confirmed) {
            const name = qs('#addHostelName').value;
            const capacity = parseInt(qs('#addHostelCapacity').value);
            const available = parseInt(qs('#addHostelAvailable').value);
            const price = parseFloat(qs('#addHostelPrice').value);
            const description = qs('#addHostelDescription').value;

            if (!name || isNaN(capacity) || isNaN(available) || isNaN(price) || capacity < 0 || available < 0 || price < 0) {
                toast('Please enter valid hostel details.');
                return;
            }
            if (available > capacity) {
                toast('Available rooms cannot exceed total capacity.');
                return;
            }
            loading(true, 'Adding hostel...');
            try {
                await addDoc(collection(db, 'hostels'), {
                    name, capacity, spacesAvailable: available, price, description,
                    createdAt: serverTimestamp()
                });
                toast('Hostel added successfully!');
                loadHostelsAdmin();
            } catch (err) {
                console.error('Add hostel failed:', err);
                toast('Failed to add hostel: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    async function editHostelDialog(id) {
        loading(true, 'Fetching hostel data...');
        try {
            const hostelRef = doc(db, 'hostels', id);
            const hostelSnap = await getDoc(hostelRef);
            if (!hostelSnap.exists()) {
                toast('Hostel not found.');
                loading(false);
                return;
            }
            const hostelData = hostelSnap.data();
            loading(false);

            const confirmed = await showCustomModal('Edit Hostel', `
                <div class="form-grid">
                    <div class="field"><label>Hostel Name</label><input type="text" id="editHostelName" value="${escapeHtml(hostelData.name || '')}" /></div>
                    <div class="field"><label>Total Capacity</label><input type="number" id="editHostelCapacity" value="${escapeHtml(String(hostelData.capacity || ''))}" /></div>
                    <div class="field"><label>Available Rooms</label><input type="number" id="editHostelAvailable" value="${escapeHtml(String(hostelData.spacesAvailable || ''))}" /></div>
                    <div class="field"><label>Price Per Semester (GHS)</label><input type="number" id="editHostelPrice" step="0.01" value="${escapeHtml(String(hostelData.price || ''))}" /></div>
                    <div class="field" style="grid-column: 1 / -1;"><label>Description</label><textarea id="editHostelDescription" rows="3">${escapeHtml(hostelData.description || '')}</textarea></div>
                </div>
            `, true);

            if (confirmed) {
                const name = qs('#editHostelName').value;
                const capacity = parseInt(qs('#editHostelCapacity').value);
                const available = parseInt(qs('#editHostelAvailable').value);
                const price = parseFloat(qs('#editHostelPrice').value);
                const description = qs('#editHostelDescription').value;

                if (!name || isNaN(capacity) || isNaN(available) || isNaN(price) || capacity < 0 || available < 0 || price < 0) {
                    toast('Please enter valid hostel details.');
                    return;
                }
                if (available > capacity) {
                    toast('Available rooms cannot exceed total capacity.');
                    return;
                }

                loading(true, 'Updating hostel...');
                await updateDoc(hostelRef, {
                    name, capacity, spacesAvailable: available, price, description
                });
                toast('Hostel updated!');
                loadHostelsAdmin();
            }
        } catch (err) {
            console.error('Edit hostel failed:', err);
            toast('Failed to edit hostel: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function deleteHostel(id) {
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this hostel? This will also affect pending applications.', true);
        if (confirmed) {
            loading(true, 'Deleting hostel...');
            try {
                await deleteDoc(doc(db, 'hostels', id));
                toast('Hostel deleted!');
                loadHostelsAdmin();
                loadHostelApplicationsAdmin(); // Also reload applications table
            } catch (err) {
                console.error('Delete hostel failed:', err);
                toast('Failed to delete hostel: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    async function toggleHostelApplicationsStatus() {
        loading(true, 'Toggling application status...');
        try {
            const settingsRef = doc(db, 'settings', 'hostelApplications');
            const settingsSnap = await getDoc(settingsRef);
            let currentStatus = false;
            if (settingsSnap.exists()) {
                currentStatus = settingsSnap.data().open;
            }
            const newStatus = !currentStatus;
            await setDoc(settingsRef, { open: newStatus }, { merge: true });
            toast(`Hostel applications are now ${newStatus ? 'OPEN' : 'CLOSED'}.`);
            await updateToggleHostelButtonText(); // Update button text
        } catch (err) {
            console.error('Toggle hostel applications failed:', err);
            toast('Failed to toggle hostel applications status: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function updateToggleHostelButtonText() {
        const btn = qs('#toggleHostelAppsBtn');
        if (btn) {
            try {
                const settingsRef = doc(db, 'settings', 'hostelApplications');
                const settingsSnap = await getDoc(settingsRef);
                let isOpen = false;
                if (settingsSnap.exists()) {
                    isOpen = settingsSnap.data().open;
                }
                btn.innerHTML = `<i class="fa-solid fa-toggle-${isOpen ? 'on' : 'off'}"></i> Toggle Applications (${isOpen ? 'OPEN' : 'CLOSED'})`;
                btn.classList.toggle('primary', isOpen);
                btn.classList.toggle('secondary', !isOpen);
            } catch (err) {
                console.error('Error updating toggle button text:', err);
            }
        }
    }

    async function loadHostelApplicationsAdmin(searchTerm = '') {
        loading(true, 'Loading hostel applications...');
        try {
            const applicationsRef = collection(db, 'hostelApplications');
            const studentsRef = collection(db, 'students');

            const [applicationsSnap, studentsSnap] = await Promise.all([
                getDocs(applicationsRef),
                getDocs(studentsRef)
            ]);

            const studentsMap = new Map(studentsSnap.docs.map(doc => [doc.id, doc.data()]));

            let applications = applicationsSnap.docs.map(doc => {
                const data = doc.data();
                const student = studentsMap.get(data.studentId);
                return {
                    id: doc.id,
                    studentId: data.studentId,
                    studentName: student?.name || 'Unknown Student',
                    studentEmail: student?.email || 'N/A',
                    hostelName: data.hostelName,
                    applicationDate: data.applicationDate,
                    status: data.status
                };
            });

            if (searchTerm) {
                const lowerSearchTerm = searchTerm.toLowerCase();
                applications = applications.filter(app =>
                    app.studentName.toLowerCase().includes(lowerSearchTerm) ||
                    app.studentEmail.toLowerCase().includes(lowerSearchTerm) ||
                    app.hostelName.toLowerCase().includes(lowerSearchTerm) ||
                    app.status.toLowerCase().includes(lowerSearchTerm)
                );
            }

            applications.sort((a,b) => new Date(b.applicationDate) - new Date(a.applicationDate)); // Newest first

            const columns = ['studentName', 'hostelName', 'applicationDate', 'status'];
            const actions = [
                { text: 'Approve', class: 'primary', handler: (app) => updateHostelApplicationStatus(app.id, 'Approved'), condition: (app) => app.status === 'Pending' },
                { text: 'Reject', class: 'secondary', handler: (app) => updateHostelApplicationStatus(app.id, 'Rejected'), condition: (app) => app.status === 'Pending' }
            ];

            renderTable('hostelApplicationsTable', applications, columns, actions);
            if (applications.length === 0 && !searchTerm) {
                qs('#hostelApplicationsEmpty').style.display = 'block';
            } else {
                qs('#hostelApplicationsEmpty').style.display = 'none';
            }

        } catch (err) {
            console.error('Load hostel applications failed:', err);
            toast('Failed to load hostel applications: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function updateHostelApplicationStatus(id, status) {
        const confirmed = await showCustomModal('Confirm Action', `Are you sure you want to ${status.toLowerCase()} this application?`, true);
        if (confirmed) {
            loading(true, 'Updating application status...');
            try {
                await updateDoc(doc(db, 'hostelApplications', id), { status: status });
                toast(`Application ${status.toLowerCase()}!`);
                loadHostelApplicationsAdmin();
            } catch (err) {
                console.error('Update hostel application status failed:', err);
                toast('Failed to update application status: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Announcements Management (Admin) ---
    async function renderAnnouncementsAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-bullhorn"></i> Announcements</div>
          <div>
            <button class="btn primary" id="addAnnouncement"><i class="fa-solid fa-plus"></i> New Announcement</button>
            <button class="btn" onclick="exportTable('announcementsTable', 'Announcements_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
            <button class="btn" onclick="printTable('announcementsTable', 'Announcements List')"><i class="fa-solid fa-print"></i> Print</button>
          </div>
        </div>
        <div class="card">
          <table class="table" id="announcementsTable">
            <thead><tr><th>Title</th><th>Body</th><th>Published Date</th><th></th></tr></thead>
            <tbody></tbody>
          </table>
          <div class="empty" id="announcementsEmpty" style="display:none;">
            <i class="fa-solid fa-database"></i>
            <div>No announcements yet.</div>
            <small>Use “New Announcement” to create one.</small>
          </div>
        </div>
      `;

      await loadAnnouncementsAdmin();
      qs('#addAnnouncement').addEventListener('click', addAnnouncementDialog);
    }

    async function loadAnnouncementsAdmin() {
      loading(true, 'Loading announcements...');
      try {
        const announcementsRef = collection(db, 'announcements');
        const snapshot = await getDocs(announcementsRef);
        const announcements = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        announcements.sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0)); // Newest first

        const columns = ['title', 'body', 'createdAt'];
        const actions = [
            { text: 'Edit', class: '', handler: (ann) => editAnnouncementDialog(ann.id) },
            { text: 'Delete', class: 'secondary', handler: (ann) => deleteAnnouncement(ann.id) }
        ];

        renderTable('announcementsTable', announcements, columns, actions);
        if (announcements.length === 0) {
            qs('#announcementsEmpty').style.display = 'block';
        } else {
            qs('#announcementsEmpty').style.display = 'none';
        }
      } catch (err) {
        console.error('Load announcements error', err);
        toast('Failed to load announcements: ' + err.message);
      } finally {
        loading(false);
      }
    }

    async function addAnnouncementDialog() {
        const confirmed = await showCustomModal('Create New Announcement', `
            <div class="field"><label>Title</label><input type="text" id="addAnnTitle" placeholder="e.g., Important Update" /></div>
            <div class="field" style="margin-top:10px;"><label>Body</label><textarea id="addAnnBody" rows="5" placeholder="Details of the announcement..."></textarea></div>
        `, true);

        if (confirmed) {
            const title = qs('#addAnnTitle').value;
            const body = qs('#addAnnBody').value;
            if (!title || !body) {
                toast('Title and Body are required.');
                return;
            }
            loading(true, 'Publishing announcement...');
            try {
                await addDoc(collection(db, 'announcements'), {
                    title, body,
                    createdAt: serverTimestamp(),
                    date: new Date().toISOString() // Redundant with createdAt but kept for consistency with previous
                });
                toast('Announcement published successfully!');
                loadAnnouncementsAdmin();
            } catch (err) {
                console.error('Add announcement failed:', err);
                toast('Failed to publish announcement: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    async function editAnnouncementDialog(id) {
        loading(true, 'Fetching announcement data...');
        try {
            const annRef = doc(db, 'announcements', id);
            const annSnap = await getDoc(annRef);
            if (!annSnap.exists()) {
                toast('Announcement not found.');
                loading(false);
                return;
            }
            const annData = annSnap.data();
            loading(false);

            const confirmed = await showCustomModal('Edit Announcement', `
                <div class="field"><label>Title</label><input type="text" id="editAnnTitle" value="${escapeHtml(annData.title || '')}" /></div>
                <div class="field" style="margin-top:10px;"><label>Body</label><textarea id="editAnnBody" rows="5">${escapeHtml(annData.body || '')}</textarea></div>
            `, true);

            if (confirmed) {
                const title = qs('#editAnnTitle').value;
                const body = qs('#editAnnBody').value;
                if (!title || !body) {
                    toast('Title and Body are required.');
                    return;
                }
                loading(true, 'Updating announcement...');
                await updateDoc(annRef, { title, body });
                toast('Announcement updated!');
                loadAnnouncementsAdmin();
            }
        } catch (err) {
            console.error('Edit announcement failed:', err);
            toast('Failed to edit announcement: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function deleteAnnouncement(id) {
        const confirmed = await showCustomModal('Confirm Delete', 'Are you sure you want to delete this announcement?', true);
        if (confirmed) {
            loading(true, 'Deleting announcement...');
            try {
                await deleteDoc(doc(db, 'announcements', id));
                toast('Announcement deleted!');
                loadAnnouncementsAdmin();
            } catch (err) {
                console.error('Delete announcement failed:', err);
                toast('Failed to delete announcement: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Graduation Requests (Admin) ---
    async function renderGraduationRequestsAdmin() {
        showApp();
        main.innerHTML = `
            <div class="section-header">
                <div class="section-title"><i class="fa-solid fa-graduation-cap"></i> Graduation Requests</div>
                <div>
                    <button class="btn" onclick="exportTable('graduationRequestsTable', 'Graduation_Requests_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
                    <button class="btn" onclick="printTable('graduationRequestsTable', 'Graduation Requests List')"><i class="fa-solid fa-print"></i> Print</button>
                </div>
            </div>
            <div class="card">
                <input type="text" id="gradRequestSearchInput" placeholder="Search by student name/email/status..." class="field-input" style="width:100%; margin-bottom:15px; padding:10px; border:1px solid #ddd; border-radius:8px;">
                <table class="table" id="graduationRequestsTable">
                    <thead><tr><th>Student Name</th><th>Student Email</th><th>Submission Date</th><th>Status</th><th>Notes</th><th></th></tr></thead>
                    <tbody></tbody>
                </table>
                <div class="empty" id="graduationRequestsEmpty" style="display:none;">
                    <i class="fa-solid fa-database"></i>
                    <div>No graduation requests yet.</div>
                </div>
            </div>
        `;
        await loadGraduationRequestsAdmin();
        qs('#gradRequestSearchInput').addEventListener('input', () => loadGraduationRequestsAdmin(qs('#gradRequestSearchInput').value));
    }

    async function loadGraduationRequestsAdmin(searchTerm = '') {
        loading(true, 'Loading graduation requests...');
        try {
            const requestsRef = collection(db, 'graduationRequests');
            const studentsRef = collection(db, 'students');

            const [requestsSnap, studentsSnap] = await Promise.all([
                getDocs(requestsRef),
                getDocs(studentsRef)
            ]);

            const studentsMap = new Map(studentsSnap.docs.map(doc => [doc.id, doc.data()]));

            let requests = requestsSnap.docs.map(doc => {
                const data = doc.data();
                const student = studentsMap.get(data.studentId);
                return {
                    id: doc.id,
                    studentId: data.studentId,
                    studentName: student?.name || 'Unknown Student',
                    studentEmail: student?.email || 'N/A',
                    submissionDate: data.submissionDate,
                    status: data.status,
                    notes: data.notes || ''
                };
            });

            if (searchTerm) {
                const lowerSearchTerm = searchTerm.toLowerCase();
                requests = requests.filter(req =>
                    req.studentName.toLowerCase().includes(lowerSearchTerm) ||
                    req.studentEmail.toLowerCase().includes(lowerSearchTerm) ||
                    req.status.toLowerCase().includes(lowerSearchTerm) ||
                    req.notes.toLowerCase().includes(lowerSearchTerm)
                );
            }

            requests.sort((a,b) => new Date(b.submissionDate) - new Date(a.submissionDate)); // Newest first

            const columns = ['studentName', 'studentEmail', 'submissionDate', 'status', 'notes'];
            const actions = [
                { text: 'Approve', class: 'primary', handler: (req) => updateGraduationRequestStatus(req.id, 'Approved'), condition: (req) => req.status === 'Pending' },
                { text: 'Reject', class: 'secondary', handler: (req) => updateGraduationRequestStatus(req.id, 'Denied'), condition: (req) => req.status === 'Pending' }
            ];

            renderTable('graduationRequestsTable', requests, columns, actions);
            if (requests.length === 0 && !searchTerm) {
                qs('#graduationRequestsEmpty').style.display = 'block';
            } else {
                qs('#graduationRequestsEmpty').style.display = 'none';
            }

        } catch (err) {
            console.error('Load graduation requests failed:', err);
            toast('Failed to load graduation requests: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function updateGraduationRequestStatus(id, status) {
        const confirmed = await showCustomModal('Confirm Action', `Are you sure you want to change this request status to ${status}?`, true);
        if (confirmed) {
            loading(true, 'Updating request status...');
            try {
                const requestRef = doc(db, 'graduationRequests', id);
                await updateDoc(requestRef, { status: status });
                toast(`Request status updated to ${status}!`);
                loadGraduationRequestsAdmin();
            } catch (err) {
                console.error('Update graduation request status failed:', err);
                toast('Failed to update request status: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Clearance Requests (Admin) ---
    async function renderClearanceRequestsAdmin() {
        showApp();
        main.innerHTML = `
            <div class="section-header">
                <div class="section-title"><i class="fa-solid fa-check-circle"></i> Clearance Requests</div>
                <div>
                    <button class="btn" onclick="exportTable('clearanceRequestsTable', 'Clearance_Requests_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
                    <button class="btn" onclick="printTable('clearanceRequestsTable', 'Clearance Requests List')"><i class="fa-solid fa-print"></i> Print</button>
                </div>
            </div>
            <div class="card">
                <input type="text" id="clearanceRequestSearchInput" placeholder="Search by student name/email/status..." class="field-input" style="width:100%; margin-bottom:15px; padding:10px; border:1px solid #ddd; border-radius:8px;">
                <table class="table" id="clearanceRequestsTable">
                    <thead><tr><th>Student Name</th><th>Student Email</th><th>Submission Date</th><th>Status</th><th>Document</th><th>Notes</th><th></th></tr></thead>
                    <tbody></tbody>
                </table>
                <div class="empty" id="clearanceRequestsEmpty" style="display:none;">
                    <i class="fa-solid fa-database"></i>
                    <div>No clearance requests yet.</div>
                </div>
            </div>
        `;
        await loadClearanceRequestsAdmin();
        qs('#clearanceRequestSearchInput').addEventListener('input', () => loadClearanceRequestsAdmin(qs('#clearanceRequestSearchInput').value));
    }

    async function loadClearanceRequestsAdmin(searchTerm = '') {
        loading(true, 'Loading clearance requests...');
        try {
            const requestsRef = collection(db, 'clearanceRequests');
            const studentsRef = collection(db, 'students');

            const [requestsSnap, studentsSnap] = await Promise.all([
                getDocs(requestsRef),
                getDocs(studentsRef)
            ]);

            const studentsMap = new Map(studentsSnap.docs.map(doc => [doc.id, doc.data()]));

            let requests = requestsSnap.docs.map(doc => {
                const data = doc.data();
                const student = studentsMap.get(data.studentId);
                return {
                    id: doc.id,
                    studentId: data.studentId,
                    studentName: student?.name || 'Unknown Student',
                    studentEmail: student?.email || 'N/A',
                    submissionDate: data.submissionDate,
                    status: data.status,
                    documentURL: data.documentURL || '',
                    notes: data.notes || ''
                };
            });

            if (searchTerm) {
                const lowerSearchTerm = searchTerm.toLowerCase();
                requests = requests.filter(req =>
                    req.studentName.toLowerCase().includes(lowerSearchTerm) ||
                    req.studentEmail.toLowerCase().includes(lowerSearchTerm) ||
                    req.status.toLowerCase().includes(lowerSearchTerm) ||
                    req.notes.toLowerCase().includes(lowerSearchTerm)
                );
            }

            requests.sort((a,b) => new Date(b.submissionDate) - new Date(a.submissionDate)); // Newest first

            const columns = ['studentName', 'studentEmail', 'submissionDate', 'status', 'documentURL', 'notes'];
            const actions = [
                { text: 'Approve', class: 'primary', handler: (req) => updateClearanceRequestStatus(req.id, 'Approved'), condition: (req) => req.status === 'Pending' },
                { text: 'Reject', class: 'secondary', handler: (req) => updateClearanceRequestStatus(req.id, 'Denied'), condition: (req) => req.status === 'Pending' }
            ];

            renderTable('clearanceRequestsTable', requests, columns, actions);
            if (requests.length === 0 && !searchTerm) {
                qs('#clearanceRequestsEmpty').style.display = 'block';
            } else {
                qs('#clearanceRequestsEmpty').style.display = 'none';
            }

        } catch (err) {
            console.error('Load clearance requests failed:', err);
            toast('Failed to load clearance requests: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function updateClearanceRequestStatus(id, status) {
        const confirmed = await showCustomModal('Confirm Action', `Are you sure you want to change this request status to ${status}?`, true);
        if (confirmed) {
            loading(true, 'Updating request status...');
            try {
                const requestRef = doc(db, 'clearanceRequests', id);
                await updateDoc(requestRef, { status: status });
                toast(`Request status updated to ${status}!`);
                loadClearanceRequestsAdmin();
            } catch (err) {
                console.error('Update clearance request status failed:', err);
                toast('Failed to update request status: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }


    // --- Admin User Management ---
    async function renderAdminUsers() {
        showApp();
        main.innerHTML = `
            <div class="section-header">
                <div class="section-title"><i class="fa-solid fa-user-shield"></i> Admin Users</div>
                <div>
                    <button class="btn primary" id="addAdminUserBtn"><i class="fa-solid fa-plus"></i> Add New Admin</button>
                    <button class="btn" onclick="exportTable('adminUsersTable', 'Admin_Users_Data')"><i class="fa-solid fa-file-export"></i> Export</button>
                    <button class="btn" onclick="printTable('adminUsersTable', 'Admin Users List')"><i class="fa-solid fa-print"></i> Print</button>
                </div>
            </div>
            <div class="card">
                <table class="table" id="adminUsersTable">
                    <thead><tr><th>Email</th><th>Admin Status</th><th></th></tr></thead>
                    <tbody></tbody>
                </table>
                <div class="empty" id="adminUsersEmpty" style="display:none;">
                    <i class="fa-solid fa-database"></i>
                    <div>No other admin users.</div>
                    <small>Use “Add New Admin” to create one.</small>
                </div>
            </div>
        `;
        await loadAdminUsers();
        qs('#addAdminUserBtn').addEventListener('click', addAdminUserDialog);
    }

    async function loadAdminUsers() {
        loading(true, 'Loading admin users...');
        try {
            const adminsRef = collection(db, 'admins');
            const snapshot = await getDocs(adminsRef);
            const currentAuthUserUid = auth.currentUser ? auth.currentUser.uid : null;

            // Filter out the current logged-in admin from the list for security/usability
            const admins = snapshot.docs
                .map(doc => ({ uid: doc.id, email: doc.data().email, isAdmin: doc.data().isAdmin }))
                .filter(admin => admin.uid !== currentAuthUserUid);

            const columns = ['email', 'isAdmin'];
            const actions = [
                { text: 'Remove', class: 'secondary', handler: (admin) => removeAdminUser(admin.uid) }
            ];

            renderTable('adminUsersTable', admins, columns, actions);
            if (admins.length === 0) {
                qs('#adminUsersEmpty').style.display = 'block';
            } else {
                qs('#adminUsersEmpty').style.display = 'none';
            }
        } catch (err) {
            console.error('Load admin users failed:', err);
            toast('Failed to load admin users: ' + err.message);
        } finally {
            loading(false);
        }
    }

    async function addAdminUserDialog() {
        const confirmed = await showCustomModal('Add New Administrator', `
            <div class="field"><label>Email</label><input type="email" id="newAdminEmail" placeholder="New admin's email" /></div>
            <div class="field" style="margin-top:10px;"><label>Temporary Password</label><input type="password" id="newAdminPassword" placeholder="Minimum 6 characters" /></div>
            <p class="muted" style="margin-top:10px;">The new admin will use this temporary password to log in. They should change it immediately.</p>
        `, true);

        if (confirmed) {
            const email = qs('#newAdminEmail').value;
            const password = qs('#newAdminPassword').value;

            if (!email || !password) {
                toast('Email and temporary password are required.');
                return;
            }
            if (password.length < 6) {
                toast('Password must be at least 6 characters.');
                return;
            }
            loading(true, 'Adding new admin...');
            try {
                // 1. Create user in Firebase Authentication
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const uid = userCredential.user.uid;

                // 2. Add admin role to Firestore
                await setDoc(doc(db, 'admins', uid), {
                    email: email,
                    isAdmin: true,
                    createdAt: serverTimestamp()
                });
                toast('New admin added successfully!');
                loadAdminUsers();
            } catch (err) {
                console.error('Add new admin failed:', err);
                let errorMessage = 'Failed to add new admin.';
                if (err.code === 'auth/email-already-in-use') {
                    errorMessage = 'The email address is already in use by another account.';
                }
                toast(errorMessage);
            } finally {
                loading(false);
            }
        }
    }

    async function removeAdminUser(uid) {
        const confirmed = await showCustomModal('Confirm Removal', 'Are you sure you want to remove this administrator? They will no longer have access to this panel.', true);
        if (confirmed) {
            loading(true, 'Removing admin...');
            try {
                // Remove the admin document from Firestore
                await deleteDoc(doc(db, 'admins', uid));
                // Note: The Firebase Authentication user still exists. For a full removal,
                // this would require an Admin SDK call via a Cloud Function.
                toast('Admin removed successfully!');
                loadAdminUsers();
            } catch (err) {
                console.error('Remove admin failed:', err);
                toast('Failed to remove admin: ' + err.message);
            } finally {
                loading(false);
            }
        }
    }

    // --- Settings (Admin) ---
    async function renderSettingsAdmin() {
      showApp();
      main.innerHTML = `
        <div class="section-header">
          <div class="section-title"><i class="fa-solid fa-gear"></i> Settings</div>
        </div>
        <div class="cards">
          <div class="card">
            <h4>Seed Demo Data</h4>
            <p class="muted">Add a few sample items so the UI looks alive. Existing data will not be overwritten.</p>
            <button class="btn" id="seedBtn"><i class="fa-solid fa-seedling"></i> Seed now</button>
          </div>
          <div class="card">
            <h4>System Information</h4>
            <p class="muted">Admin access is controlled by Firestore document <code>admins/{uid}</code> where <code>isAdmin</code> is <code>true</code>.</p>
            <p class="muted">Firebase Project ID: <code>${escapeHtml(firebaseConfig.projectId)}</code></p>
            <p class="muted">Logged-in Admin UID: <code>${escapeHtml(auth.currentUser ? auth.currentUser.uid : 'N/A')}</code></p>
          </div>
           <div class="card">
            <h4>Maintenance Mode</h4>
            <p class="muted">Toggle site-wide maintenance mode (feature coming soon).</p>
            <button class="btn secondary"><i class="fa-solid fa-tools"></i> Toggle Maintenance</button>
          </div>
        </div>
      `;
      qs('#seedBtn').addEventListener('click', seedDemo);
    }

    async function seedDemo() {
      const confirmed = await showCustomModal('Seed Demo Data', 'This will add sample student, course, registration, and announcement data if collections are empty. Continue?', true);
      if (!confirmed) return;

      loading(true, 'Seeding demo data...');
      try {
        const batch = db.batch();

        // Students
        const studentsCollection = collection(db, 'students');
        const studentsSnap = await getDocs(studentsCollection);
        if (studentsSnap.empty) {
            const s1Ref = doc(studentsCollection, 'student_uid_1');
            const s2Ref = doc(studentsCollection, 'student_uid_2');
            batch.set(s1Ref, { name:'Alice Wonderland', email:'alice@example.com', programme:'Graphic Design', year:1, contact:'+1234567890', regNo:'PADU/2023/001', campus:'Main Campus', dob:'2005-01-15', gender:'Female', address:'123 Design St', profilePhotoURL:'https://placehold.co/100x100/eeeeee/333333?text=A', createdAt: serverTimestamp(), initialized:true });
            batch.set(s2Ref, { name:'Bob Builder', email:'bob@example.com', programme:'Architecture', year:2, contact:'+1987654321', regNo:'PADU/2022/002', campus:'Satellite Campus', dob:'2004-05-20', gender:'Male', address:'456 Build Rd', profilePhotoURL:'https://placehold.co/100x100/eeeeee/333333?text=B', createdAt: serverTimestamp(), initialized:true });
            console.log("Seeding students...");
        }

        // Courses
        const coursesCollection = collection(db, 'courses');
        const coursesSnap = await getDocs(coursesCollection);
        if (coursesSnap.empty) {
            batch.set(doc(coursesCollection, 'course_id_1'), { code:'DES101', courseName:'Intro to Design', credits:3, lecturer:'Dr. Emily Art', schedule:'Mon,Wed 09:00-11:00', createdAt: serverTimestamp() });
            batch.set(doc(coursesCollection, 'course_id_2'), { code:'ARC201', courseName:'Structural Analysis', credits:4, lecturer:'Prof. David Beam', schedule:'Tue,Thu 13:00-15:00', createdAt: serverTimestamp() });
            console.log("Seeding courses...");
        }

        // Registrations
        const registrationsCollection = collection(db, 'registrations');
        const regsSnap = await getDocs(registrationsCollection);
        if (regsSnap.empty) {
            // Alice registers for DES101
            batch.set(doc(registrationsCollection, 'student_uid_1'), {
                studentId: 'student_uid_1',
                courses: arrayUnion({
                    id: 'course_id_1',
                    courseCode: 'DES101',
                    courseName: 'Intro to Design',
                    registrationDate: new Date().toISOString(),
                    status: 'Registered'
                })
            });
            // Bob registers for ARC201
            batch.set(doc(registrationsCollection, 'student_uid_2'), {
                studentId: 'student_uid_2',
                courses: arrayUnion({
                    id: 'course_id_2',
                    courseCode: 'ARC201',
                    courseName: 'Structural Analysis',
                    registrationDate: new Date().toISOString(),
                    status: 'Registered'
                })
            });
            console.log("Seeding registrations...");
        }

        // Announcements
        const announcementsCollection = collection(db, 'announcements');
        const annSnap = await getDocs(announcementsCollection);
        if (annSnap.empty) {
            batch.set(doc(announcementsCollection), { title:'Welcome to New Term!', body:'Classes officially begin on September 1st. Please check your timetable.', createdAt: serverTimestamp(), date: new Date().toISOString() });
            batch.set(doc(announcementsCollection), { title:'Career Fair', body:'Join us for our annual career fair on Oct 10th. Many companies will be hiring!', createdAt: serverTimestamp(), date: new Date(Date.now() - 86400000).toISOString() }); // Yesterday
            console.log("Seeding announcements...");
        }

        // Fees
        const feesCollection = collection(db, 'fees');
        const feesSnap = await getDocs(feesCollection);
        if (feesSnap.empty) {
            // Alice's fees
            batch.set(doc(feesCollection, 'student_uid_1'), {
                studentId: 'student_uid_1',
                totalFees: 5000.00,
                payments: [
                    { date: new Date(Date.now() - 30*24*60*60*1000).toISOString(), description: 'Tuition Fee - Semester 1', amount: 5000.00, type: 'charge' },
                    { date: new Date(Date.now() - 15*24*60*60*1000).toISOString(), description: 'Payment 1', amount: 3000.00, type: 'payment' }
                ]
            });
            // Bob's fees
            batch.set(doc(feesCollection, 'student_uid_2'), {
                studentId: 'student_uid_2',
                totalFees: 6000.00,
                payments: [
                    { date: new Date(Date.now() - 45*24*60*60*1000).toISOString(), description: 'Tuition Fee - Semester 1', amount: 6000.00, type: 'charge' },
                    { date: new Date(Date.now() - 10*24*60*60*1000).toISOString(), description: 'Payment 1', amount: 6000.00, type: 'payment' }
                ]
            });
            console.log("Seeding fees...");
        }

        // Grades
        const gradesCollection = collection(db, 'grades');
        const gradesSnap = await getDocs(gradesCollection);
        if (gradesSnap.empty) {
            batch.set(doc(gradesCollection), { studentId: 'student_uid_1', courseId: 'course_id_1', courseCode:'DES101', courseName:'Intro to Design', grade:'A', courseUnit:3, remarks:'Excellent work', recordedAt: serverTimestamp() });
            batch.set(doc(gradesCollection), { studentId: 'student_uid_2', courseId: 'course_id_2', courseCode:'ARC201', courseName:'Structural Analysis', grade:'B+', courseUnit:4, remarks:'Good understanding', recordedAt: serverTimestamp() });
            console.log("Seeding grades...");
        }

        // Hostels
        const hostelsCollection = collection(db, 'hostels');
        const hostelsSnap = await getDocs(hostelsCollection);
        if (hostelsSnap.empty) {
            batch.set(doc(hostelsCollection, 'hostel_id_1'), { name:'Harmony Hall', capacity:150, spacesAvailable:100, price:2500.00, description:'Modern hostel for all students.', createdAt: serverTimestamp() });
            batch.set(doc(hostelsCollection, 'hostel_id_2'), { name:'Innovation Suites', capacity:80, spacesAvailable:30, price:3500.00, description:'Premium hostel with private rooms.', createdAt: serverTimestamp() });
            console.log("Seeding hostels...");
        }

        // Hostel Applications
        const hostelAppsCollection = collection(db, 'hostelApplications');
        const hostelAppsSnap = await getDocs(hostelAppsCollection);
        if (hostelAppsSnap.empty) {
             batch.set(doc(hostelAppsCollection, 'student_uid_1'), {
                studentId: 'student_uid_1',
                studentName: 'Alice Wonderland',
                hostelId: 'hostel_id_1',
                hostelName: 'Harmony Hall',
                applicationDate: new Date().toISOString(),
                status: 'Pending'
             });
             console.log("Seeding hostel applications...");
        }
        // Hostel applications setting
        const hostelSettingsRef = doc(db, 'settings', 'hostelApplications');
        const hostelSettingsSnap = await getDoc(hostelSettingsRef);
        if (!hostelSettingsSnap.exists()) {
            batch.set(hostelSettingsRef, { open: true });
            console.log("Seeding hostel settings...");
        }

        // Graduation Requests
        const gradRequestsCollection = collection(db, 'graduationRequests');
        const gradRequestsSnap = await getDocs(gradRequestsCollection);
        if (gradRequestsSnap.empty) {
            batch.add(gradRequestsCollection, { studentId: 'student_uid_1', submissionDate: new Date(Date.now() - 7*24*60*60*1000).toISOString(), status:'Pending', notes:'Awaiting final grade check.' });
            batch.add(gradRequestsCollection, { studentId: 'student_uid_2', submissionDate: new Date(Date.now() - 14*24*60*60*1000).toISOString(), status:'Approved', notes:'All clear for graduation.' });
            console.log("Seeding graduation requests...");
        }

        // Clearance Requests
        const clearanceRequestsCollection = collection(db, 'clearanceRequests');
        const clearanceRequestsSnap = await getDocs(clearanceRequestsCollection);
        if (clearanceRequestsSnap.empty) {
            batch.add(clearanceRequestsCollection, { studentId: 'student_uid_1', submissionDate: new Date(Date.now() - 5*24*60*60*1000).toISOString(), status:'Pending', documentURL:'https://placehold.co/100x100/eeeeee/333333?text=PDF_Doc_1', notes:'Awaiting library clearance.' });
            batch.add(clearanceRequestsCollection, { studentId: 'student_uid_2', submissionDate: new Date(Date.now() - 10*24*60*60*1000).toISOString(), status:'Approved', documentURL:'https://placehold.co/100x100/eeeeee/333333?text=PDF_Doc_2', notes:'All departments clear.' });
            console.log("Seeding clearance requests...");
        }

        // Admins
        const adminsCollection = collection(db, 'admins');
        const adminsSnap = await getDocs(adminsCollection);
        if (adminsSnap.empty && auth.currentUser) {
            // Seed a sample admin if the current authenticated user isn't already an admin
            const currentUid = auth.currentUser.uid;
            const currentAdminDoc = await getDoc(doc(adminsCollection, currentUid));
            if (!currentAdminDoc.exists()) {
                batch.set(doc(adminsCollection, currentUid), { email: auth.currentUser.email || 'seeded_admin@example.com', isAdmin: true, createdAt: serverTimestamp() });
                console.log("Seeding current user as admin...");
            }
        }

        await batch.commit();
        toast('Demo data seeded successfully!');
        renderDashboard(); // Refresh dashboard with new seeded data
      } catch (err) {
        console.error('Seed failed:', err);
        toast('Seed failed: ' + err.message);
      } finally {
        loading(false);
      }
    }


    // Default view on first load
    // This will be handled by onAuthStateChanged after initial authentication check.
    // If the user is authenticated as admin, renderDashboard() will be called.

  </script>
</body>
</html>
